{"ast":null,"code":"function e(e) {\n  function t(e, t) {\n    Error.captureStackTrace && Error.captureStackTrace(this, this.constructor), this.message = e, this.code = t;\n  }\n  return t.prototype = new Error(), t.prototype.name = e, t.prototype.constructor = t, t;\n}\nconst t = e(\"LaunchDarklyUnexpectedResponseError\"),\n  n = e(\"LaunchDarklyInvalidEnvironmentIdError\"),\n  r = e(\"LaunchDarklyInvalidUserError\"),\n  o = e(\"LaunchDarklyInvalidEventKeyError\"),\n  i = e(\"LaunchDarklyInvalidArgumentError\"),\n  a = e(\"LaunchDarklyFlagFetchError\");\nfor (var s = {\n    LDUnexpectedResponseError: t,\n    LDInvalidEnvironmentIdError: n,\n    LDInvalidUserError: r,\n    LDInvalidEventKeyError: o,\n    LDInvalidArgumentError: i,\n    LDInvalidDataError: e(\"LaunchDarklyInvalidDataError\"),\n    LDFlagFetchError: a,\n    LDTimeoutError: e(\"LaunchDarklyTimeoutError\"),\n    isHttpErrorRecoverable: function (e) {\n      return !(e >= 400 && e < 500) || 400 === e || 408 === e || 429 === e;\n    }\n  }, c = function (e) {\n    var t = m(e),\n      n = t[0],\n      r = t[1];\n    return 3 * (n + r) / 4 - r;\n  }, u = function (e) {\n    var t,\n      n,\n      r = m(e),\n      o = r[0],\n      i = r[1],\n      a = new g(function (e, t, n) {\n        return 3 * (t + n) / 4 - n;\n      }(0, o, i)),\n      s = 0,\n      c = i > 0 ? o - 4 : o;\n    for (n = 0; n < c; n += 4) t = f[e.charCodeAt(n)] << 18 | f[e.charCodeAt(n + 1)] << 12 | f[e.charCodeAt(n + 2)] << 6 | f[e.charCodeAt(n + 3)], a[s++] = t >> 16 & 255, a[s++] = t >> 8 & 255, a[s++] = 255 & t;\n    2 === i && (t = f[e.charCodeAt(n)] << 2 | f[e.charCodeAt(n + 1)] >> 4, a[s++] = 255 & t);\n    1 === i && (t = f[e.charCodeAt(n)] << 10 | f[e.charCodeAt(n + 1)] << 4 | f[e.charCodeAt(n + 2)] >> 2, a[s++] = t >> 8 & 255, a[s++] = 255 & t);\n    return a;\n  }, l = function (e) {\n    for (var t, n = e.length, r = n % 3, o = [], i = 16383, a = 0, s = n - r; a < s; a += i) o.push(h(e, a, a + i > s ? s : a + i));\n    1 === r ? (t = e[n - 1], o.push(d[t >> 2] + d[t << 4 & 63] + \"==\")) : 2 === r && (t = (e[n - 2] << 8) + e[n - 1], o.push(d[t >> 10] + d[t >> 4 & 63] + d[t << 2 & 63] + \"=\"));\n    return o.join(\"\");\n  }, d = [], f = [], g = \"undefined\" != typeof Uint8Array ? Uint8Array : Array, v = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\", p = 0; p < 64; ++p) d[p] = v[p], f[v.charCodeAt(p)] = p;\nfunction m(e) {\n  var t = e.length;\n  if (t % 4 > 0) throw new Error(\"Invalid string. Length must be a multiple of 4\");\n  var n = e.indexOf(\"=\");\n  return -1 === n && (n = t), [n, n === t ? 0 : 4 - n % 4];\n}\nfunction h(e, t, n) {\n  for (var r, o, i = [], a = t; a < n; a += 3) r = (e[a] << 16 & 16711680) + (e[a + 1] << 8 & 65280) + (255 & e[a + 2]), i.push(d[(o = r) >> 18 & 63] + d[o >> 12 & 63] + d[o >> 6 & 63] + d[63 & o]);\n  return i.join(\"\");\n}\nf[\"-\".charCodeAt(0)] = 62, f[\"_\".charCodeAt(0)] = 63;\nvar y = {\n    byteLength: c,\n    toByteArray: u,\n    fromByteArray: l\n  },\n  w = Array.isArray,\n  b = Object.keys,\n  k = Object.prototype.hasOwnProperty,\n  E = function e(t, n) {\n    if (t === n) return !0;\n    if (t && n && \"object\" == typeof t && \"object\" == typeof n) {\n      var r,\n        o,\n        i,\n        a = w(t),\n        s = w(n);\n      if (a && s) {\n        if ((o = t.length) != n.length) return !1;\n        for (r = o; 0 != r--;) if (!e(t[r], n[r])) return !1;\n        return !0;\n      }\n      if (a != s) return !1;\n      var c = t instanceof Date,\n        u = n instanceof Date;\n      if (c != u) return !1;\n      if (c && u) return t.getTime() == n.getTime();\n      var l = t instanceof RegExp,\n        d = n instanceof RegExp;\n      if (l != d) return !1;\n      if (l && d) return t.toString() == n.toString();\n      var f = b(t);\n      if ((o = f.length) !== b(n).length) return !1;\n      for (r = o; 0 != r--;) if (!k.call(n, f[r])) return !1;\n      for (r = o; 0 != r--;) if (!e(t[i = f[r]], n[i])) return !1;\n      return !0;\n    }\n    return t != t && n != n;\n  };\nconst D = [\"key\", \"ip\", \"country\", \"email\", \"firstName\", \"lastName\", \"avatar\", \"name\"];\nfunction x(e) {\n  const t = unescape(encodeURIComponent(e));\n  return y.fromByteArray(function (e) {\n    const t = [];\n    for (let n = 0; n < e.length; n++) t.push(e.charCodeAt(n));\n    return t;\n  }(t));\n}\nfunction C(e, t) {\n  return Object.prototype.hasOwnProperty.call(e, t);\n}\nvar P,\n  S = {\n    appendUrlPath: function (e, t) {\n      return (e.endsWith(\"/\") ? e.substring(0, e.length - 1) : e) + (t.startsWith(\"/\") ? \"\" : \"/\") + t;\n    },\n    base64URLEncode: function (e) {\n      return x(e).replace(/=/g, \"\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n    },\n    btoa: x,\n    clone: function (e) {\n      return JSON.parse(JSON.stringify(e));\n    },\n    deepEquals: function (e, t) {\n      return E(e, t);\n    },\n    extend: function () {\n      for (var _len = arguments.length, e = new Array(_len), _key = 0; _key < _len; _key++) {\n        e[_key] = arguments[_key];\n      }\n      return e.reduce((e, t) => ({\n        ...e,\n        ...t\n      }), {});\n    },\n    getLDUserAgentString: function (e) {\n      const t = e.version || \"?\";\n      return e.userAgent + \"/\" + t;\n    },\n    objectHasOwnProperty: C,\n    onNextTick: function (e) {\n      setTimeout(e, 0);\n    },\n    sanitizeContext: function (e) {\n      if (!e) return e;\n      let t;\n      return null !== e.kind && void 0 !== e.kind || D.forEach(n => {\n        const r = e[n];\n        void 0 !== r && \"string\" != typeof r && (t = t || {\n          ...e\n        }, t[n] = String(r));\n      }), t || e;\n    },\n    transformValuesToVersionedValues: function (e) {\n      const t = {};\n      for (const n in e) C(e, n) && (t[n] = {\n        value: e[n],\n        version: 0\n      });\n      return t;\n    },\n    transformVersionedValuesToValues: function (e) {\n      const t = {};\n      for (const n in e) C(e, n) && (t[n] = e[n].value);\n      return t;\n    },\n    wrapPromiseCallback: function (e, t) {\n      const n = e.then(e => (t && setTimeout(() => {\n        t(null, e);\n      }, 0), e), e => {\n        if (!t) return Promise.reject(e);\n        setTimeout(() => {\n          t(e, null);\n        }, 0);\n      });\n      return t ? void 0 : n;\n    }\n  },\n  I = new Uint8Array(16);\nfunction O() {\n  if (!P && !(P = \"undefined\" != typeof crypto && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || \"undefined\" != typeof msCrypto && \"function\" == typeof msCrypto.getRandomValues && msCrypto.getRandomValues.bind(msCrypto))) throw new Error(\"crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported\");\n  return P(I);\n}\nvar T = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;\nfunction L(e) {\n  return \"string\" == typeof e && T.test(e);\n}\nfor (var U, R, A = [], j = 0; j < 256; ++j) A.push((j + 256).toString(16).substr(1));\nfunction F(e) {\n  var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,\n    n = (A[e[t + 0]] + A[e[t + 1]] + A[e[t + 2]] + A[e[t + 3]] + \"-\" + A[e[t + 4]] + A[e[t + 5]] + \"-\" + A[e[t + 6]] + A[e[t + 7]] + \"-\" + A[e[t + 8]] + A[e[t + 9]] + \"-\" + A[e[t + 10]] + A[e[t + 11]] + A[e[t + 12]] + A[e[t + 13]] + A[e[t + 14]] + A[e[t + 15]]).toLowerCase();\n  if (!L(n)) throw TypeError(\"Stringified UUID is invalid\");\n  return n;\n}\nvar N = 0,\n  $ = 0;\nfunction V(e) {\n  if (!L(e)) throw TypeError(\"Invalid UUID\");\n  var t,\n    n = new Uint8Array(16);\n  return n[0] = (t = parseInt(e.slice(0, 8), 16)) >>> 24, n[1] = t >>> 16 & 255, n[2] = t >>> 8 & 255, n[3] = 255 & t, n[4] = (t = parseInt(e.slice(9, 13), 16)) >>> 8, n[5] = 255 & t, n[6] = (t = parseInt(e.slice(14, 18), 16)) >>> 8, n[7] = 255 & t, n[8] = (t = parseInt(e.slice(19, 23), 16)) >>> 8, n[9] = 255 & t, n[10] = (t = parseInt(e.slice(24, 36), 16)) / 1099511627776 & 255, n[11] = t / 4294967296 & 255, n[12] = t >>> 24 & 255, n[13] = t >>> 16 & 255, n[14] = t >>> 8 & 255, n[15] = 255 & t, n;\n}\nfunction M(e, t, n) {\n  function r(e, r, o, i) {\n    if (\"string\" == typeof e && (e = function (e) {\n      e = unescape(encodeURIComponent(e));\n      for (var t = [], n = 0; n < e.length; ++n) t.push(e.charCodeAt(n));\n      return t;\n    }(e)), \"string\" == typeof r && (r = V(r)), 16 !== r.length) throw TypeError(\"Namespace must be array-like (16 iterable integer values, 0-255)\");\n    var a = new Uint8Array(16 + e.length);\n    if (a.set(r), a.set(e, r.length), (a = n(a))[6] = 15 & a[6] | t, a[8] = 63 & a[8] | 128, o) {\n      i = i || 0;\n      for (var s = 0; s < 16; ++s) o[i + s] = a[s];\n      return o;\n    }\n    return F(a);\n  }\n  try {\n    r.name = e;\n  } catch (e) {}\n  return r.DNS = \"6ba7b810-9dad-11d1-80b4-00c04fd430c8\", r.URL = \"6ba7b811-9dad-11d1-80b4-00c04fd430c8\", r;\n}\nfunction H(e) {\n  return 14 + (e + 64 >>> 9 << 4) + 1;\n}\nfunction q(e, t) {\n  var n = (65535 & e) + (65535 & t);\n  return (e >> 16) + (t >> 16) + (n >> 16) << 16 | 65535 & n;\n}\nfunction z(e, t, n, r, o, i) {\n  return q((a = q(q(t, e), q(r, i))) << (s = o) | a >>> 32 - s, n);\n  var a, s;\n}\nfunction K(e, t, n, r, o, i, a) {\n  return z(t & n | ~t & r, e, t, o, i, a);\n}\nfunction _(e, t, n, r, o, i, a) {\n  return z(t & r | n & ~r, e, t, o, i, a);\n}\nfunction J(e, t, n, r, o, i, a) {\n  return z(t ^ n ^ r, e, t, o, i, a);\n}\nfunction B(e, t, n, r, o, i, a) {\n  return z(n ^ (t | ~r), e, t, o, i, a);\n}\nvar G = M(\"v3\", 48, function (e) {\n    if (\"string\" == typeof e) {\n      var t = unescape(encodeURIComponent(e));\n      e = new Uint8Array(t.length);\n      for (var n = 0; n < t.length; ++n) e[n] = t.charCodeAt(n);\n    }\n    return function (e) {\n      for (var t = [], n = 32 * e.length, r = \"0123456789abcdef\", o = 0; o < n; o += 8) {\n        var i = e[o >> 5] >>> o % 32 & 255,\n          a = parseInt(r.charAt(i >>> 4 & 15) + r.charAt(15 & i), 16);\n        t.push(a);\n      }\n      return t;\n    }(function (e, t) {\n      e[t >> 5] |= 128 << t % 32, e[H(t) - 1] = t;\n      for (var n = 1732584193, r = -271733879, o = -1732584194, i = 271733878, a = 0; a < e.length; a += 16) {\n        var s = n,\n          c = r,\n          u = o,\n          l = i;\n        n = K(n, r, o, i, e[a], 7, -680876936), i = K(i, n, r, o, e[a + 1], 12, -389564586), o = K(o, i, n, r, e[a + 2], 17, 606105819), r = K(r, o, i, n, e[a + 3], 22, -1044525330), n = K(n, r, o, i, e[a + 4], 7, -176418897), i = K(i, n, r, o, e[a + 5], 12, 1200080426), o = K(o, i, n, r, e[a + 6], 17, -1473231341), r = K(r, o, i, n, e[a + 7], 22, -45705983), n = K(n, r, o, i, e[a + 8], 7, 1770035416), i = K(i, n, r, o, e[a + 9], 12, -1958414417), o = K(o, i, n, r, e[a + 10], 17, -42063), r = K(r, o, i, n, e[a + 11], 22, -1990404162), n = K(n, r, o, i, e[a + 12], 7, 1804603682), i = K(i, n, r, o, e[a + 13], 12, -40341101), o = K(o, i, n, r, e[a + 14], 17, -1502002290), n = _(n, r = K(r, o, i, n, e[a + 15], 22, 1236535329), o, i, e[a + 1], 5, -165796510), i = _(i, n, r, o, e[a + 6], 9, -1069501632), o = _(o, i, n, r, e[a + 11], 14, 643717713), r = _(r, o, i, n, e[a], 20, -373897302), n = _(n, r, o, i, e[a + 5], 5, -701558691), i = _(i, n, r, o, e[a + 10], 9, 38016083), o = _(o, i, n, r, e[a + 15], 14, -660478335), r = _(r, o, i, n, e[a + 4], 20, -405537848), n = _(n, r, o, i, e[a + 9], 5, 568446438), i = _(i, n, r, o, e[a + 14], 9, -1019803690), o = _(o, i, n, r, e[a + 3], 14, -187363961), r = _(r, o, i, n, e[a + 8], 20, 1163531501), n = _(n, r, o, i, e[a + 13], 5, -1444681467), i = _(i, n, r, o, e[a + 2], 9, -51403784), o = _(o, i, n, r, e[a + 7], 14, 1735328473), n = J(n, r = _(r, o, i, n, e[a + 12], 20, -1926607734), o, i, e[a + 5], 4, -378558), i = J(i, n, r, o, e[a + 8], 11, -2022574463), o = J(o, i, n, r, e[a + 11], 16, 1839030562), r = J(r, o, i, n, e[a + 14], 23, -35309556), n = J(n, r, o, i, e[a + 1], 4, -1530992060), i = J(i, n, r, o, e[a + 4], 11, 1272893353), o = J(o, i, n, r, e[a + 7], 16, -155497632), r = J(r, o, i, n, e[a + 10], 23, -1094730640), n = J(n, r, o, i, e[a + 13], 4, 681279174), i = J(i, n, r, o, e[a], 11, -358537222), o = J(o, i, n, r, e[a + 3], 16, -722521979), r = J(r, o, i, n, e[a + 6], 23, 76029189), n = J(n, r, o, i, e[a + 9], 4, -640364487), i = J(i, n, r, o, e[a + 12], 11, -421815835), o = J(o, i, n, r, e[a + 15], 16, 530742520), n = B(n, r = J(r, o, i, n, e[a + 2], 23, -995338651), o, i, e[a], 6, -198630844), i = B(i, n, r, o, e[a + 7], 10, 1126891415), o = B(o, i, n, r, e[a + 14], 15, -1416354905), r = B(r, o, i, n, e[a + 5], 21, -57434055), n = B(n, r, o, i, e[a + 12], 6, 1700485571), i = B(i, n, r, o, e[a + 3], 10, -1894986606), o = B(o, i, n, r, e[a + 10], 15, -1051523), r = B(r, o, i, n, e[a + 1], 21, -2054922799), n = B(n, r, o, i, e[a + 8], 6, 1873313359), i = B(i, n, r, o, e[a + 15], 10, -30611744), o = B(o, i, n, r, e[a + 6], 15, -1560198380), r = B(r, o, i, n, e[a + 13], 21, 1309151649), n = B(n, r, o, i, e[a + 4], 6, -145523070), i = B(i, n, r, o, e[a + 11], 10, -1120210379), o = B(o, i, n, r, e[a + 2], 15, 718787259), r = B(r, o, i, n, e[a + 9], 21, -343485551), n = q(n, s), r = q(r, c), o = q(o, u), i = q(i, l);\n      }\n      return [n, r, o, i];\n    }(function (e) {\n      if (0 === e.length) return [];\n      for (var t = 8 * e.length, n = new Uint32Array(H(t)), r = 0; r < t; r += 8) n[r >> 5] |= (255 & e[r / 8]) << r % 32;\n      return n;\n    }(e), 8 * e.length));\n  }),\n  W = G;\nfunction X(e, t, n, r) {\n  switch (e) {\n    case 0:\n      return t & n ^ ~t & r;\n    case 1:\n    case 3:\n      return t ^ n ^ r;\n    case 2:\n      return t & n ^ t & r ^ n & r;\n  }\n}\nfunction Q(e, t) {\n  return e << t | e >>> 32 - t;\n}\nvar Y = M(\"v5\", 80, function (e) {\n    var t = [1518500249, 1859775393, 2400959708, 3395469782],\n      n = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];\n    if (\"string\" == typeof e) {\n      var r = unescape(encodeURIComponent(e));\n      e = [];\n      for (var o = 0; o < r.length; ++o) e.push(r.charCodeAt(o));\n    } else Array.isArray(e) || (e = Array.prototype.slice.call(e));\n    e.push(128);\n    for (var i = e.length / 4 + 2, a = Math.ceil(i / 16), s = new Array(a), c = 0; c < a; ++c) {\n      for (var u = new Uint32Array(16), l = 0; l < 16; ++l) u[l] = e[64 * c + 4 * l] << 24 | e[64 * c + 4 * l + 1] << 16 | e[64 * c + 4 * l + 2] << 8 | e[64 * c + 4 * l + 3];\n      s[c] = u;\n    }\n    s[a - 1][14] = 8 * (e.length - 1) / Math.pow(2, 32), s[a - 1][14] = Math.floor(s[a - 1][14]), s[a - 1][15] = 8 * (e.length - 1) & 4294967295;\n    for (var d = 0; d < a; ++d) {\n      for (var f = new Uint32Array(80), g = 0; g < 16; ++g) f[g] = s[d][g];\n      for (var v = 16; v < 80; ++v) f[v] = Q(f[v - 3] ^ f[v - 8] ^ f[v - 14] ^ f[v - 16], 1);\n      for (var p = n[0], m = n[1], h = n[2], y = n[3], w = n[4], b = 0; b < 80; ++b) {\n        var k = Math.floor(b / 20),\n          E = Q(p, 5) + X(k, m, h, y) + w + t[k] + f[b] >>> 0;\n        w = y, y = h, h = Q(m, 30) >>> 0, m = p, p = E;\n      }\n      n[0] = n[0] + p >>> 0, n[1] = n[1] + m >>> 0, n[2] = n[2] + h >>> 0, n[3] = n[3] + y >>> 0, n[4] = n[4] + w >>> 0;\n    }\n    return [n[0] >> 24 & 255, n[0] >> 16 & 255, n[0] >> 8 & 255, 255 & n[0], n[1] >> 24 & 255, n[1] >> 16 & 255, n[1] >> 8 & 255, 255 & n[1], n[2] >> 24 & 255, n[2] >> 16 & 255, n[2] >> 8 & 255, 255 & n[2], n[3] >> 24 & 255, n[3] >> 16 & 255, n[3] >> 8 & 255, 255 & n[3], n[4] >> 24 & 255, n[4] >> 16 & 255, n[4] >> 8 & 255, 255 & n[4]];\n  }),\n  Z = Y;\nvar ee = Object.freeze({\n  __proto__: null,\n  v1: function (e, t, n) {\n    var r = t && n || 0,\n      o = t || new Array(16),\n      i = (e = e || {}).node || U,\n      a = void 0 !== e.clockseq ? e.clockseq : R;\n    if (null == i || null == a) {\n      var s = e.random || (e.rng || O)();\n      null == i && (i = U = [1 | s[0], s[1], s[2], s[3], s[4], s[5]]), null == a && (a = R = 16383 & (s[6] << 8 | s[7]));\n    }\n    var c = void 0 !== e.msecs ? e.msecs : Date.now(),\n      u = void 0 !== e.nsecs ? e.nsecs : $ + 1,\n      l = c - N + (u - $) / 1e4;\n    if (l < 0 && void 0 === e.clockseq && (a = a + 1 & 16383), (l < 0 || c > N) && void 0 === e.nsecs && (u = 0), u >= 1e4) throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n    N = c, $ = u, R = a;\n    var d = (1e4 * (268435455 & (c += 122192928e5)) + u) % 4294967296;\n    o[r++] = d >>> 24 & 255, o[r++] = d >>> 16 & 255, o[r++] = d >>> 8 & 255, o[r++] = 255 & d;\n    var f = c / 4294967296 * 1e4 & 268435455;\n    o[r++] = f >>> 8 & 255, o[r++] = 255 & f, o[r++] = f >>> 24 & 15 | 16, o[r++] = f >>> 16 & 255, o[r++] = a >>> 8 | 128, o[r++] = 255 & a;\n    for (var g = 0; g < 6; ++g) o[r + g] = i[g];\n    return t || F(o);\n  },\n  v3: W,\n  v4: function (e, t, n) {\n    var r = (e = e || {}).random || (e.rng || O)();\n    if (r[6] = 15 & r[6] | 64, r[8] = 63 & r[8] | 128, t) {\n      n = n || 0;\n      for (var o = 0; o < 16; ++o) t[n + o] = r[o];\n      return t;\n    }\n    return F(r);\n  },\n  v5: Z,\n  NIL: \"00000000-0000-0000-0000-000000000000\",\n  version: function (e) {\n    if (!L(e)) throw TypeError(\"Invalid UUID\");\n    return parseInt(e.substr(14, 1), 16);\n  },\n  validate: L,\n  stringify: F,\n  parse: V\n});\nconst te = [\"debug\", \"info\", \"warn\", \"error\", \"none\"];\nvar ne = {\n  commonBasicLogger: function (e, t) {\n    if (e && e.destination && \"function\" != typeof e.destination) throw new Error(\"destination for basicLogger was set to a non-function\");\n    function n(e) {\n      return function (t) {\n        console && console[e] && console[e].call(console, t);\n      };\n    }\n    const r = e && e.destination ? [e.destination, e.destination, e.destination, e.destination] : [n(\"log\"), n(\"info\"), n(\"warn\"), n(\"error\")],\n      o = !(!e || !e.destination),\n      i = e && void 0 !== e.prefix && null !== e.prefix ? e.prefix : \"[LaunchDarkly] \";\n    let a = 1;\n    if (e && e.level) for (let t = 0; t < te.length; t++) te[t] === e.level && (a = t);\n    function s(e, n, a) {\n      if (a.length < 1) return;\n      let s;\n      const c = o ? n + \": \" + i : i;\n      if (1 !== a.length && t) {\n        const e = [...a];\n        e[0] = c + e[0], s = t(...e);\n      } else s = c + a[0];\n      try {\n        r[e](s);\n      } catch (e) {\n        console && console.log && console.log(\"[LaunchDarkly] Configured logger's \" + n + \" method threw an exception: \" + e);\n      }\n    }\n    const c = {};\n    for (let e = 0; e < te.length; e++) {\n      const t = te[e];\n      if (\"none\" !== t) if (e < a) c[t] = () => {};else {\n        const n = e;\n        c[t] = function () {\n          s(n, t, arguments);\n        };\n      }\n    }\n    return c;\n  },\n  validateLogger: function (e) {\n    te.forEach(t => {\n      if (\"none\" !== t && (!e[t] || \"function\" != typeof e[t])) throw new Error(\"Provided logger instance must support logger.\" + t + \"(...) method\");\n    });\n  }\n};\nfunction re(e) {\n  return e && e.message ? e.message : \"string\" == typeof e || e instanceof String ? e : JSON.stringify(e);\n}\nconst oe = \" Please see https://docs.launchdarkly.com/sdk/client-side/javascript#initialize-the-client for instructions on SDK initialization.\";\nvar ie = {\n  bootstrapInvalid: function () {\n    return \"LaunchDarkly bootstrap data is not available because the back end could not read the flags.\";\n  },\n  bootstrapOldFormat: function () {\n    return \"LaunchDarkly client was initialized with bootstrap data that did not include flag metadata. Events may not be sent correctly.\" + oe;\n  },\n  clientInitialized: function () {\n    return \"LaunchDarkly client initialized\";\n  },\n  clientNotReady: function () {\n    return \"LaunchDarkly client is not ready\";\n  },\n  debugEnqueueingEvent: function (e) {\n    return 'enqueueing \"' + e + '\" event';\n  },\n  debugPostingDiagnosticEvent: function (e) {\n    return \"sending diagnostic event (\" + e.kind + \")\";\n  },\n  debugPostingEvents: function (e) {\n    return \"sending \" + e + \" events\";\n  },\n  debugStreamDelete: function (e) {\n    return 'received streaming deletion for flag \"' + e + '\"';\n  },\n  debugStreamDeleteIgnored: function (e) {\n    return 'received streaming deletion for flag \"' + e + '\" but ignored due to version check';\n  },\n  debugStreamPatch: function (e) {\n    return 'received streaming update for flag \"' + e + '\"';\n  },\n  debugStreamPatchIgnored: function (e) {\n    return 'received streaming update for flag \"' + e + '\" but ignored due to version check';\n  },\n  debugStreamPing: function () {\n    return \"received ping message from stream\";\n  },\n  debugPolling: function (e) {\n    return \"polling for feature flags at \" + e;\n  },\n  debugStreamPut: function () {\n    return \"received streaming update for all flags\";\n  },\n  deprecated: function (e, t) {\n    return t ? '\"' + e + '\" is deprecated, please use \"' + t + '\"' : '\"' + e + '\" is deprecated';\n  },\n  environmentNotFound: function () {\n    return \"Environment not found. Double check that you specified a valid environment/client-side ID.\" + oe;\n  },\n  environmentNotSpecified: function () {\n    return \"No environment/client-side ID was specified.\" + oe;\n  },\n  errorFetchingFlags: function (e) {\n    return \"Error fetching flag settings: \" + re(e);\n  },\n  eventCapacityExceeded: function () {\n    return \"Exceeded event queue capacity. Increase capacity to avoid dropping events.\";\n  },\n  eventWithoutContext: function () {\n    return \"Be sure to call `identify` in the LaunchDarkly client: https://docs.launchdarkly.com/sdk/features/identify#javascript\";\n  },\n  httpErrorMessage: function (e, t, n) {\n    return \"Received error \" + e + (401 === e ? \" (invalid SDK key)\" : \"\") + \" for \" + t + \" - \" + (s.isHttpErrorRecoverable(e) ? n : \"giving up permanently\");\n  },\n  httpUnavailable: function () {\n    return \"Cannot make HTTP requests in this environment.\" + oe;\n  },\n  identifyDisabled: function () {\n    return \"identify() has no effect here; it must be called on the main client instance\";\n  },\n  inspectorMethodError: (e, t) => `an inspector: \"${t}\" of type: \"${e}\" generated an exception`,\n  invalidContentType: function (e) {\n    return 'Expected application/json content type but got \"' + e + '\"';\n  },\n  invalidData: function () {\n    return \"Invalid data received from LaunchDarkly; connection may have been interrupted\";\n  },\n  invalidInspector: (e, t) => `an inspector: \"${t}\" of an invalid type (${e}) was configured`,\n  invalidKey: function () {\n    return \"Event key must be a string\";\n  },\n  invalidMetricValue: e => `The track function was called with a non-numeric \"metricValue\" (${e}), only numeric metric values are supported.`,\n  invalidContext: function () {\n    return \"Invalid context specified.\" + oe;\n  },\n  invalidTagValue: e => `Config option \"${e}\" must only contain letters, numbers, ., _ or -.`,\n  localStorageUnavailable: function (e) {\n    return \"local storage is unavailable: \" + re(e);\n  },\n  networkError: e => \"network error\" + (e ? \" (\" + e + \")\" : \"\"),\n  optionBelowMinimum: (e, t, n) => 'Config option \"' + e + '\" was set to ' + t + \", changing to minimum value of \" + n,\n  streamClosing: function () {\n    return \"Closing stream connection\";\n  },\n  streamConnecting: function (e) {\n    return \"Opening stream connection to \" + e;\n  },\n  streamError: function (e, t) {\n    return \"Error on stream connection: \" + re(e) + \", will continue retrying after \" + t + \" milliseconds.\";\n  },\n  tagValueTooLong: e => `Value of \"${e}\" was longer than 64 characters and was discarded.`,\n  unknownCustomEventKey: function (e) {\n    return 'Custom event \"' + e + '\" does not exist';\n  },\n  unknownOption: e => 'Ignoring unknown config option \"' + e + '\"',\n  contextNotSpecified: function () {\n    return \"No context specified.\" + oe;\n  },\n  unrecoverableStreamError: e => `Error on stream connection ${re(e)}, giving up permanently`,\n  wrongOptionType: (e, t, n) => 'Config option \"' + e + '\" should be of type ' + t + \", got \" + n + \", using default value\",\n  wrongOptionTypeBoolean: (e, t) => 'Config option \"' + e + '\" should be a boolean, got ' + t + \", converting to boolean\"\n};\nconst {\n    validateLogger: ae\n  } = ne,\n  se = {\n    baseUrl: {\n      default: \"https://app.launchdarkly.com\"\n    },\n    streamUrl: {\n      default: \"https://clientstream.launchdarkly.com\"\n    },\n    eventsUrl: {\n      default: \"https://events.launchdarkly.com\"\n    },\n    sendEvents: {\n      default: !0\n    },\n    streaming: {\n      type: \"boolean\"\n    },\n    sendLDHeaders: {\n      default: !0\n    },\n    requestHeaderTransform: {\n      type: \"function\"\n    },\n    sendEventsOnlyForVariation: {\n      default: !1\n    },\n    useReport: {\n      default: !1\n    },\n    evaluationReasons: {\n      default: !1\n    },\n    eventCapacity: {\n      default: 100,\n      minimum: 1\n    },\n    flushInterval: {\n      default: 2e3,\n      minimum: 2e3\n    },\n    samplingInterval: {\n      default: 0,\n      minimum: 0\n    },\n    streamReconnectDelay: {\n      default: 1e3,\n      minimum: 0\n    },\n    allAttributesPrivate: {\n      default: !1\n    },\n    privateAttributes: {\n      default: []\n    },\n    bootstrap: {\n      type: \"string|object\"\n    },\n    diagnosticRecordingInterval: {\n      default: 9e5,\n      minimum: 2e3\n    },\n    diagnosticOptOut: {\n      default: !1\n    },\n    wrapperName: {\n      type: \"string\"\n    },\n    wrapperVersion: {\n      type: \"string\"\n    },\n    stateProvider: {\n      type: \"object\"\n    },\n    application: {\n      validator: function (e, t, n) {\n        const r = {};\n        t.id && (r.id = le(`${e}.id`, t.id, n));\n        t.version && (r.version = le(`${e}.version`, t.version, n));\n        return r;\n      }\n    },\n    inspectors: {\n      default: []\n    }\n  },\n  ce = /^(\\w|\\.|-)+$/;\nfunction ue(e) {\n  return e && e.replace(/\\/+$/, \"\");\n}\nfunction le(e, t, n) {\n  if (\"string\" == typeof t && t.match(ce)) {\n    if (!(t.length > 64)) return t;\n    n.warn(ie.tagValueTooLong(e));\n  } else n.warn(ie.invalidTagValue(e));\n}\nvar de = {\n  baseOptionDefs: se,\n  validate: function (e, t, n, r) {\n    const o = S.extend({\n        logger: {\n          default: r\n        }\n      }, se, n),\n      i = {};\n    function a(e) {\n      S.onNextTick(() => {\n        t && t.maybeReportError(new s.LDInvalidArgumentError(e));\n      });\n    }\n    let c = S.extend({}, e || {});\n    return function (e) {\n      const t = e;\n      Object.keys(i).forEach(e => {\n        if (void 0 !== t[e]) {\n          const n = i[e];\n          r && r.warn(ie.deprecated(e, n)), n && (void 0 === t[n] && (t[n] = t[e]), delete t[e]);\n        }\n      });\n    }(c), c = function (e) {\n      const t = S.extend({}, e);\n      return Object.keys(o).forEach(e => {\n        void 0 !== t[e] && null !== t[e] || (t[e] = o[e] && o[e].default);\n      }), t;\n    }(c), c = function (e) {\n      const t = S.extend({}, e),\n        n = e => {\n          if (null === e) return \"any\";\n          if (void 0 === e) return;\n          if (Array.isArray(e)) return \"array\";\n          const t = typeof e;\n          return \"boolean\" === t || \"string\" === t || \"number\" === t || \"function\" === t ? t : \"object\";\n        };\n      return Object.keys(e).forEach(i => {\n        const s = e[i];\n        if (null != s) {\n          const c = o[i];\n          if (void 0 === c) a(ie.unknownOption(i));else {\n            const o = c.type || n(c.default),\n              u = c.validator;\n            if (u) {\n              const n = u(i, e[i], r);\n              void 0 !== n ? t[i] = n : delete t[i];\n            } else if (\"any\" !== o) {\n              const e = o.split(\"|\"),\n                r = n(s);\n              e.indexOf(r) < 0 ? \"boolean\" === o ? (t[i] = !!s, a(ie.wrongOptionTypeBoolean(i, r))) : (a(ie.wrongOptionType(i, o, r)), t[i] = c.default) : \"number\" === r && void 0 !== c.minimum && s < c.minimum && (a(ie.optionBelowMinimum(i, s, c.minimum)), t[i] = c.minimum);\n            }\n          }\n        }\n      }), t.baseUrl = ue(t.baseUrl), t.streamUrl = ue(t.streamUrl), t.eventsUrl = ue(t.eventsUrl), t;\n    }(c), ae(c.logger), c;\n  },\n  getTags: function (e) {\n    const t = {};\n    return e && (e.application && void 0 !== e.application.id && null !== e.application.id && (t[\"application-id\"] = [e.application.id]), e.application && void 0 !== e.application.version && null !== e.application.id && (t[\"application-version\"] = [e.application.version])), t;\n  }\n};\nconst {\n  getLDUserAgentString: fe\n} = S;\nvar ge = {\n  getLDHeaders: function (e, t) {\n    if (t && !t.sendLDHeaders) return {};\n    const n = {};\n    n[e.userAgentHeaderName || \"User-Agent\"] = fe(e), t && t.wrapperName && (n[\"X-LaunchDarkly-Wrapper\"] = t.wrapperVersion ? t.wrapperName + \"/\" + t.wrapperVersion : t.wrapperName);\n    const r = de.getTags(t),\n      o = Object.keys(r);\n    return o.length && (n[\"x-launchdarkly-tags\"] = o.sort().map(e => Array.isArray(r[e]) ? r[e].sort().map(t => `${e}/${t}`) : [`${e}/${r[e]}`]).reduce((e, t) => e.concat(t), []).join(\" \")), n;\n  },\n  transformHeaders: function (e, t) {\n    return t && t.requestHeaderTransform ? t.requestHeaderTransform({\n      ...e\n    }) : e;\n  }\n};\nconst {\n    v1: ve\n  } = ee,\n  {\n    getLDHeaders: pe,\n    transformHeaders: me\n  } = ge;\nvar he = function (e, t, n) {\n  const r = S.extend({\n      \"Content-Type\": \"application/json\"\n    }, pe(e, n)),\n    o = {};\n  return o.sendEvents = (t, o, i) => {\n    if (!e.httpRequest) return Promise.resolve();\n    const a = JSON.stringify(t),\n      c = i ? null : ve();\n    return function t(u) {\n      const l = i ? r : S.extend({}, r, {\n        \"X-LaunchDarkly-Event-Schema\": \"4\",\n        \"X-LaunchDarkly-Payload-ID\": c\n      });\n      return e.httpRequest(\"POST\", o, me(l, n), a).promise.then(e => {\n        if (e) return e.status >= 400 && s.isHttpErrorRecoverable(e.status) && u ? t(!1) : function (e) {\n          const t = {\n              status: e.status\n            },\n            n = e.header(\"date\");\n          if (n) {\n            const e = Date.parse(n);\n            e && (t.serverTime = e);\n          }\n          return t;\n        }(e);\n      }).catch(() => u ? t(!1) : Promise.reject());\n    }(!0).catch(() => {});\n  }, o;\n};\nconst {\n  commonBasicLogger: ye\n} = ne;\nfunction we(e) {\n  return \"string\" == typeof e && \"kind\" !== e && e.match(/^(\\w|\\.|-)+$/);\n}\nfunction be(e) {\n  return e.includes(\"%\") || e.includes(\":\") ? e.replace(/%/g, \"%25\").replace(/:/g, \"%3A\") : e;\n}\nvar ke = {\n  checkContext: function (e, t) {\n    if (e) {\n      if (t && (void 0 === e.kind || null === e.kind)) return void 0 !== e.key && null !== e.key;\n      const n = e.key,\n        r = void 0 === e.kind ? \"user\" : e.kind,\n        o = we(r),\n        i = \"multi\" === r || null != n && \"\" !== n;\n      if (\"multi\" === r) {\n        const t = Object.keys(e).filter(e => \"kind\" !== e);\n        return i && t.every(e => we(e)) && t.every(t => {\n          const n = e[t].key;\n          return null != n && \"\" !== n;\n        });\n      }\n      return i && o;\n    }\n    return !1;\n  },\n  getContextKeys: function (e) {\n    let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ye();\n    if (!e) return;\n    const n = {},\n      {\n        kind: r,\n        key: o\n      } = e;\n    switch (r) {\n      case void 0:\n        n.user = `${o}`;\n        break;\n      case \"multi\":\n        Object.entries(e).filter(_ref => {\n          let [e] = _ref;\n          return \"kind\" !== e;\n        }).forEach(_ref2 => {\n          let [e, t] = _ref2;\n          t && t.key && (n[e] = t.key);\n        });\n        break;\n      case null:\n        t.warn(`null is not a valid context kind: ${e}`);\n        break;\n      case \"\":\n        t.warn(`'' is not a valid context kind: ${e}`);\n        break;\n      default:\n        n[r] = `${o}`;\n    }\n    return n;\n  },\n  getContextKinds: function (e) {\n    return e ? null === e.kind || void 0 === e.kind ? [\"user\"] : \"multi\" !== e.kind ? [e.kind] : Object.keys(e).filter(e => \"kind\" !== e) : [];\n  },\n  getCanonicalKey: function (e) {\n    if (e) {\n      if ((void 0 === e.kind || null === e.kind || \"user\" === e.kind) && e.key) return e.key;\n      if (\"multi\" !== e.kind && e.key) return `${e.kind}:${be(e.key)}`;\n      if (\"multi\" === e.kind) return Object.keys(e).sort().filter(e => \"kind\" !== e).map(t => `${t}:${be(e[t].key)}`).join(\":\");\n    }\n  }\n};\nconst {\n  getContextKinds: Ee\n} = ke;\nvar De = function () {\n  const e = {};\n  let t = 0,\n    n = 0,\n    r = {},\n    o = {};\n  return e.summarizeEvent = e => {\n    if (\"feature\" === e.kind) {\n      const i = e.key + \":\" + (null !== e.variation && void 0 !== e.variation ? e.variation : \"\") + \":\" + (null !== e.version && void 0 !== e.version ? e.version : \"\"),\n        a = r[i];\n      let s = o[e.key];\n      s || (s = new Set(), o[e.key] = s), function (e) {\n        return e.context ? Ee(e.context) : e.contextKeys ? Object.keys(e.contextKeys) : [];\n      }(e).forEach(e => s.add(e)), a ? a.count = a.count + 1 : r[i] = {\n        count: 1,\n        key: e.key,\n        version: e.version,\n        variation: e.variation,\n        value: e.value,\n        default: e.default\n      }, (0 === t || e.creationDate < t) && (t = e.creationDate), e.creationDate > n && (n = e.creationDate);\n    }\n  }, e.getSummary = () => {\n    const e = {};\n    let i = !0;\n    for (const t of Object.values(r)) {\n      let n = e[t.key];\n      n || (n = {\n        default: t.default,\n        counters: [],\n        contextKinds: [...o[t.key]]\n      }, e[t.key] = n);\n      const r = {\n        value: t.value,\n        count: t.count\n      };\n      void 0 !== t.variation && null !== t.variation && (r.variation = t.variation), void 0 !== t.version && null !== t.version ? r.version = t.version : r.unknown = !0, n.counters.push(r), i = !1;\n    }\n    return i ? null : {\n      startDate: t,\n      endDate: n,\n      features: e\n    };\n  }, e.clearSummary = () => {\n    t = 0, n = 0, r = {}, o = {};\n  }, e;\n};\nfunction xe(e) {\n  return e.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n}\nfunction Ce(e) {\n  return (e.startsWith(\"/\") ? e.substring(1) : e).split(\"/\").map(e => e.indexOf(\"~\") >= 0 ? e.replace(/~1/g, \"/\").replace(/~0/g, \"~\") : e);\n}\nfunction Pe(e) {\n  return !e.startsWith(\"/\");\n}\nfunction Se(e, t) {\n  const n = Pe(e),\n    r = Pe(t);\n  if (n && r) return e === t;\n  if (n) {\n    const n = Ce(t);\n    return 1 === n.length && e === n[0];\n  }\n  if (r) {\n    const n = Ce(e);\n    return 1 === n.length && t === n[0];\n  }\n  return e === t;\n}\nfunction Ie(e) {\n  return `/${xe(e)}`;\n}\nvar Oe = {\n  cloneExcluding: function (e, t) {\n    const n = [],\n      r = {},\n      o = [];\n    for (n.push(...Object.keys(e).map(t => ({\n      key: t,\n      ptr: Ie(t),\n      source: e,\n      parent: r,\n      visited: [e]\n    }))); n.length;) {\n      const e = n.pop();\n      if (t.some(t => Se(t, e.ptr))) o.push(e.ptr);else {\n        const t = e.source[e.key];\n        if (null === t) e.parent[e.key] = t;else if (Array.isArray(t)) e.parent[e.key] = [...t];else if (\"object\" == typeof t) {\n          if (e.visited.includes(t)) continue;\n          e.parent[e.key] = {}, n.push(...Object.keys(t).map(n => {\n            return {\n              key: n,\n              ptr: (r = e.ptr, o = xe(n), `${r}/${o}`),\n              source: t,\n              parent: e.parent[e.key],\n              visited: [...e.visited, t]\n            };\n            var r, o;\n          }));\n        } else e.parent[e.key] = t;\n      }\n    }\n    return {\n      cloned: r,\n      excluded: o.sort()\n    };\n  },\n  compare: Se,\n  literalToReference: Ie\n};\nvar Te = function (e) {\n  const t = {},\n    n = e.allAttributesPrivate,\n    r = e.privateAttributes || [],\n    o = [\"key\", \"kind\", \"_meta\", \"anonymous\"],\n    i = [\"name\", \"ip\", \"firstName\", \"lastName\", \"email\", \"avatar\", \"country\"],\n    a = (e, t) => {\n      if (\"object\" != typeof e || null === e || Array.isArray(e)) return;\n      const {\n        cloned: i,\n        excluded: a\n      } = Oe.cloneExcluding(e, ((e, t) => (n || t && e.anonymous ? Object.keys(e) : [...r, ...(e._meta && e._meta.privateAttributes || [])]).filter(e => !o.some(t => Oe.compare(e, t))))(e, t));\n      return i.key = String(i.key), a.length && (i._meta || (i._meta = {}), i._meta.redactedAttributes = a), i._meta && (delete i._meta.privateAttributes, 0 === Object.keys(i._meta).length && delete i._meta), void 0 !== i.anonymous && (i.anonymous = !!i.anonymous), i;\n    };\n  return t.filter = function (e) {\n    let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;\n    return void 0 === e.kind || null === e.kind ? a((e => {\n      const t = {\n        ...(e.custom || {}),\n        kind: \"user\",\n        key: e.key\n      };\n      void 0 !== e.anonymous && (t.anonymous = !!e.anonymous);\n      for (const n of i) delete t[n], void 0 !== e[n] && null !== e[n] && (t[n] = String(e[n]));\n      return void 0 !== e.privateAttributeNames && null !== e.privateAttributeNames && (t._meta = t._meta || {}, t._meta.privateAttributes = e.privateAttributeNames.map(e => e.startsWith(\"/\") ? Oe.literalToReference(e) : e)), t;\n    })(e), t) : \"multi\" === e.kind ? ((e, t) => {\n      const n = {\n          kind: e.kind\n        },\n        r = Object.keys(e);\n      for (const o of r) if (\"kind\" !== o) {\n        const r = a(e[o], t);\n        r && (n[o] = r);\n      }\n      return n;\n    })(e, t) : a(e, t);\n  }, t;\n};\nconst {\n  getContextKeys: Le\n} = ke;\nvar Ue = function (e, t, n) {\n  let r = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  let o = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  let i = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n  const a = {},\n    c = i || he(e, n, t),\n    u = S.appendUrlPath(t.eventsUrl, \"/events/bulk/\" + n),\n    l = De(),\n    d = Te(t),\n    f = t.samplingInterval,\n    g = t.eventCapacity,\n    v = t.flushInterval,\n    p = t.logger;\n  let m,\n    h = [],\n    y = 0,\n    w = !1,\n    b = !1;\n  function k() {\n    return 0 === f || 0 === Math.floor(Math.random() * f);\n  }\n  function E(e) {\n    const t = S.extend({}, e);\n    return \"identify\" === e.kind ? t.context = d.filter(e.context) : \"feature\" === e.kind ? t.context = d.filter(e.context, !0) : (t.contextKeys = Le(e.context, p), delete t.context), \"feature\" === e.kind && (delete t.trackEvents, delete t.debugEventsUntilDate), t;\n  }\n  function D(e) {\n    h.length < g ? (h.push(e), b = !1) : (b || (b = !0, p.warn(ie.eventCapacityExceeded())), r && r.incrementDroppedEvents());\n  }\n  return a.enqueue = function (e) {\n    if (w) return;\n    let t = !1,\n      n = !1;\n    var r;\n    if (l.summarizeEvent(e), \"feature\" === e.kind ? k() && (t = !!e.trackEvents, n = !!(r = e).debugEventsUntilDate && r.debugEventsUntilDate > y && r.debugEventsUntilDate > new Date().getTime()) : t = k(), t && D(E(e)), n) {\n      const t = S.extend({}, e, {\n        kind: \"debug\"\n      });\n      t.context = d.filter(t.context), delete t.trackEvents, delete t.debugEventsUntilDate, D(t);\n    }\n  }, a.flush = function () {\n    if (w) return Promise.resolve();\n    const e = h,\n      t = l.getSummary();\n    return l.clearSummary(), t && (t.kind = \"summary\", e.push(t)), r && r.setEventsInLastBatch(e.length), 0 === e.length ? Promise.resolve() : (h = [], p.debug(ie.debugPostingEvents(e.length)), c.sendEvents(e, u).then(e => {\n      e && (e.serverTime && (y = e.serverTime), s.isHttpErrorRecoverable(e.status) || (w = !0), e.status >= 400 && S.onNextTick(() => {\n        o.maybeReportError(new s.LDUnexpectedResponseError(ie.httpErrorMessage(e.status, \"event posting\", \"some events were dropped\")));\n      }));\n    }));\n  }, a.start = function () {\n    const e = () => {\n      a.flush(), m = setTimeout(e, v);\n    };\n    m = setTimeout(e, v);\n  }, a.stop = function () {\n    clearTimeout(m);\n  }, a;\n};\nvar Re = function (e) {\n  const t = {},\n    n = {};\n  return t.on = function (e, t, r) {\n    n[e] = n[e] || [], n[e] = n[e].concat({\n      handler: t,\n      context: r\n    });\n  }, t.off = function (e, t, r) {\n    if (n[e]) for (let o = 0; o < n[e].length; o++) n[e][o].handler === t && n[e][o].context === r && (n[e] = n[e].slice(0, o).concat(n[e].slice(o + 1)));\n  }, t.emit = function (e) {\n    if (!n[e]) return;\n    const t = n[e].slice(0);\n    for (let e = 0; e < t.length; e++) t[e].handler.apply(t[e].context, Array.prototype.slice.call(arguments, 1));\n  }, t.getEvents = function () {\n    return Object.keys(n);\n  }, t.getEventListenerCount = function (e) {\n    return n[e] ? n[e].length : 0;\n  }, t.maybeReportError = function (t) {\n    t && (n[\"error\"] ? this.emit(\"error\", t) : (e || console).error(t.message));\n  }, t;\n};\nconst Ae = \"ready\",\n  je = \"initialized\",\n  Fe = \"failed\";\nvar Ne = function (e) {\n  let t = !1,\n    n = !1,\n    r = null,\n    o = null;\n  const i = new Promise(t => {\n    const n = () => {\n      e.off(Ae, n), t();\n    };\n    e.on(Ae, n);\n  }).catch(() => {});\n  return {\n    getInitializationPromise: () => o || (t ? Promise.resolve() : n ? Promise.reject(r) : (o = new Promise((t, n) => {\n      const r = () => {\n          e.off(je, r), t();\n        },\n        o = t => {\n          e.off(Fe, o), n(t);\n        };\n      e.on(je, r), e.on(Fe, o);\n    }), o)),\n    getReadyPromise: () => i,\n    signalSuccess: () => {\n      t || n || (t = !0, e.emit(je), e.emit(Ae));\n    },\n    signalFailure: o => {\n      t || n || (n = !0, r = o, e.emit(Fe, o), e.emit(Ae)), e.maybeReportError(o);\n    }\n  };\n};\nvar $e = function (e, t, n, r) {\n  const o = {};\n  function i() {\n    let e = \"\";\n    const o = r.getContext();\n    return o && (e = n || S.btoa(JSON.stringify(o))), \"ld:\" + t + \":\" + e;\n  }\n  return o.loadFlags = () => e.get(i()).then(e => {\n    if (null == e) return null;\n    try {\n      let t = JSON.parse(e);\n      if (t) {\n        const e = t.$schema;\n        void 0 === e || e < 1 ? t = S.transformValuesToVersionedValues(t) : delete t.$schema;\n      }\n      return t;\n    } catch (e) {\n      return o.clearFlags().then(() => null);\n    }\n  }), o.saveFlags = t => {\n    const n = S.extend({}, t, {\n      $schema: 1\n    });\n    return e.set(i(), JSON.stringify(n));\n  }, o.clearFlags = () => e.clear(i()), o;\n};\nvar Ve = function (e, t) {\n  const n = {};\n  let r = !1;\n  const o = e => {\n    r || (r = !0, t.warn(ie.localStorageUnavailable(e)));\n  };\n  return n.isEnabled = () => !!e, n.get = t => new Promise(n => {\n    e ? e.get(t).then(n).catch(e => {\n      o(e), n(void 0);\n    }) : n(void 0);\n  }), n.set = (t, n) => new Promise(r => {\n    e ? e.set(t, n).then(() => r(!0)).catch(e => {\n      o(e), r(!1);\n    }) : r(!1);\n  }), n.clear = t => new Promise(n => {\n    e ? e.clear(t).then(() => n(!0)).catch(e => {\n      o(e), n(!1);\n    }) : n(!1);\n  }), n;\n};\nconst {\n    appendUrlPath: Me,\n    base64URLEncode: He,\n    objectHasOwnProperty: qe\n  } = S,\n  {\n    getLDHeaders: ze,\n    transformHeaders: Ke\n  } = ge,\n  {\n    isHttpErrorRecoverable: _e\n  } = s;\nvar Je = function (e, t, n, r) {\n  const o = t.streamUrl,\n    i = t.logger,\n    a = {},\n    s = Me(o, \"/eval/\" + n),\n    c = t.useReport,\n    u = t.evaluationReasons,\n    l = t.streamReconnectDelay,\n    d = ze(e, t);\n  let f,\n    g = !1,\n    v = null,\n    p = null,\n    m = null,\n    h = null,\n    y = null,\n    w = 0;\n  function b() {\n    const e = (t = function () {\n      const e = l * Math.pow(2, w);\n      return e > 3e4 ? 3e4 : e;\n    }(), t - Math.trunc(.5 * Math.random() * t));\n    var t;\n    return w += 1, e;\n  }\n  function k(e) {\n    if (e.status && \"number\" == typeof e.status && !_e(e.status)) return x(), i.error(ie.unrecoverableStreamError(e)), void (p && (clearTimeout(p), p = null));\n    const t = b();\n    g || (i.warn(ie.streamError(e, t)), g = !0), C(!1), x(), E(t);\n  }\n  function E(e) {\n    p || (e ? p = setTimeout(D, e) : D());\n  }\n  function D() {\n    let r;\n    p = null;\n    let a = \"\";\n    const l = {\n      headers: d,\n      readTimeoutMillis: 3e5\n    };\n    if (e.eventSourceFactory) {\n      null != h && (a = \"h=\" + h), c ? e.eventSourceAllowsReport ? (r = s, l.method = \"REPORT\", l.headers[\"Content-Type\"] = \"application/json\", l.body = JSON.stringify(m)) : (r = Me(o, \"/ping/\" + n), a = \"\") : r = s + \"/\" + He(JSON.stringify(m)), l.headers = Ke(l.headers, t), u && (a = a + (a ? \"&\" : \"\") + \"withReasons=true\"), r = r + (a ? \"?\" : \"\") + a, x(), i.info(ie.streamConnecting(r)), f = new Date().getTime(), v = e.eventSourceFactory(r, l);\n      for (const e in y) qe(y, e) && v.addEventListener(e, y[e]);\n      v.onerror = k, v.onopen = () => {\n        w = 0;\n      };\n    }\n  }\n  function x() {\n    v && (i.info(ie.streamClosing()), v.close(), v = null);\n  }\n  function C(e) {\n    f && r && r.recordStreamInit(f, !e, new Date().getTime() - f), f = null;\n  }\n  return a.connect = function (e, t, n) {\n    m = e, h = t, y = {};\n    for (const e in n || {}) y[e] = function (t) {\n      g = !1, C(!0), n[e] && n[e](t);\n    };\n    E();\n  }, a.disconnect = function () {\n    clearTimeout(p), p = null, x();\n  }, a.isConnected = function () {\n    return !!(v && e.eventSourceIsActive && e.eventSourceIsActive(v));\n  }, a;\n};\nvar Be = function (e) {\n  let t, n, r, o;\n  const i = {\n    addPromise: (i, a) => {\n      t = i, n && n(), n = a, i.then(n => {\n        t === i && (r(n), e && e());\n      }, n => {\n        t === i && (o(n), e && e());\n      });\n    }\n  };\n  return i.resultPromise = new Promise((e, t) => {\n    r = e, o = t;\n  }), i;\n};\nconst {\n    transformHeaders: Ge,\n    getLDHeaders: We\n  } = ge,\n  Xe = \"application/json\";\nvar Qe = function (e, t, n) {\n  const r = t.baseUrl,\n    o = t.useReport,\n    i = t.evaluationReasons,\n    a = t.logger,\n    c = {},\n    u = {};\n  function l(n, r) {\n    if (!e.httpRequest) return new Promise((e, t) => {\n      t(new s.LDFlagFetchError(ie.httpUnavailable()));\n    });\n    const o = r ? \"REPORT\" : \"GET\",\n      i = We(e, t);\n    r && (i[\"Content-Type\"] = Xe);\n    let a = u[n];\n    a || (a = Be(() => {\n      delete u[n];\n    }), u[n] = a);\n    const c = e.httpRequest(o, n, Ge(i, t), r),\n      l = c.promise.then(e => {\n        if (200 === e.status) {\n          if (e.header(\"content-type\") && e.header(\"content-type\").substring(0, 16) === Xe) return JSON.parse(e.body);\n          {\n            const t = ie.invalidContentType(e.header(\"content-type\") || \"\");\n            return Promise.reject(new s.LDFlagFetchError(t));\n          }\n        }\n        return Promise.reject(function (e) {\n          return 404 === e.status ? new s.LDInvalidEnvironmentIdError(ie.environmentNotFound()) : new s.LDFlagFetchError(ie.errorFetchingFlags(e.statusText || String(e.status)));\n        }(e));\n      }, e => Promise.reject(new s.LDFlagFetchError(ie.networkError(e))));\n    return a.addPromise(l, () => {\n      c.cancel && c.cancel();\n    }), a.resultPromise;\n  }\n  return c.fetchJSON = function (e) {\n    return l(S.appendUrlPath(r, e), null);\n  }, c.fetchFlagSettings = function (e, t) {\n    let s,\n      c,\n      u,\n      d = \"\";\n    return o ? (c = [r, \"/sdk/evalx/\", n, \"/context\"].join(\"\"), u = JSON.stringify(e)) : (s = S.base64URLEncode(JSON.stringify(e)), c = [r, \"/sdk/evalx/\", n, \"/contexts/\", s].join(\"\")), t && (d = \"h=\" + t), i && (d = d + (d ? \"&\" : \"\") + \"withReasons=true\"), c = c + (d ? \"?\" : \"\") + d, a.debug(ie.debugPolling(c)), l(c, u);\n  }, c;\n};\nvar Ye = function (e, t) {\n  const n = {};\n  let r;\n  return n.setContext = function (e) {\n    r = S.sanitizeContext(e), r && t && t(S.clone(r));\n  }, n.getContext = function () {\n    return r ? S.clone(r) : null;\n  }, e && n.setContext(e), n;\n};\nconst {\n    v1: Ze\n  } = ee,\n  {\n    getContextKinds: et\n  } = ke;\nvar tt = function (e) {\n  function t(e) {\n    return null == e || \"user\" === e ? \"ld:$anonUserId\" : `ld:$contextKey:${e}`;\n  }\n  function n(n, r) {\n    return null !== r.key && void 0 !== r.key ? (r.key = r.key.toString(), Promise.resolve(r)) : r.anonymous ? function (n) {\n      return e.get(t(n));\n    }(n).then(o => {\n      if (o) return r.key = o, r;\n      {\n        const o = Ze();\n        return r.key = o, function (n, r) {\n          return e.set(t(r), n);\n        }(o, n).then(() => r);\n      }\n    }) : Promise.reject(new s.LDInvalidUserError(ie.invalidContext()));\n  }\n  this.processContext = e => {\n    if (!e) return Promise.reject(new s.LDInvalidUserError(ie.contextNotSpecified()));\n    const t = S.clone(e);\n    if (\"multi\" === e.kind) {\n      const e = et(t);\n      return Promise.all(e.map(e => n(e, t[e]))).then(() => t);\n    }\n    return n(e.kind, t);\n  };\n};\nconst {\n    v1: nt\n  } = ee,\n  {\n    baseOptionDefs: rt\n  } = de,\n  {\n    appendUrlPath: ot\n  } = S;\nvar it = {\n  DiagnosticId: function (e) {\n    const t = {\n      diagnosticId: nt()\n    };\n    return e && (t.sdkKeySuffix = e.length > 6 ? e.substring(e.length - 6) : e), t;\n  },\n  DiagnosticsAccumulator: function (e) {\n    let t, n, r, o;\n    function i(e) {\n      t = e, n = 0, r = 0, o = [];\n    }\n    return i(e), {\n      getProps: () => ({\n        dataSinceDate: t,\n        droppedEvents: n,\n        eventsInLastBatch: r,\n        streamInits: o\n      }),\n      setProps: e => {\n        t = e.dataSinceDate, n = e.droppedEvents || 0, r = e.eventsInLastBatch || 0, o = e.streamInits || [];\n      },\n      incrementDroppedEvents: () => {\n        n++;\n      },\n      setEventsInLastBatch: e => {\n        r = e;\n      },\n      recordStreamInit: (e, t, n) => {\n        const r = {\n          timestamp: e,\n          failed: t,\n          durationMillis: n\n        };\n        o.push(r);\n      },\n      reset: i\n    };\n  },\n  DiagnosticsManager: function (e, t, n, r, o, i, a) {\n    const s = !!e.diagnosticUseCombinedEvent,\n      c = \"ld:\" + o + \":$diagnostics\",\n      u = ot(i.eventsUrl, \"/events/diagnostic/\" + o),\n      l = i.diagnosticRecordingInterval,\n      d = n;\n    let f,\n      g,\n      v = !!i.streaming;\n    const p = {};\n    function m() {\n      return {\n        sdk: w(),\n        configuration: b(),\n        platform: e.diagnosticPlatformData\n      };\n    }\n    function h(e) {\n      i.logger && i.logger.debug(ie.debugPostingDiagnosticEvent(e)), r.sendEvents(e, u, !0).then(() => {}).catch(() => {});\n    }\n    function y() {\n      h(function () {\n        const e = new Date().getTime();\n        let t = {\n          kind: s ? \"diagnostic-combined\" : \"diagnostic\",\n          id: a,\n          creationDate: e,\n          ...d.getProps()\n        };\n        return s && (t = {\n          ...t,\n          ...m()\n        }), d.reset(e), t;\n      }()), g = setTimeout(y, l), f = new Date().getTime(), s && function () {\n        if (t.isEnabled()) {\n          const e = {\n            ...d.getProps()\n          };\n          t.set(c, JSON.stringify(e));\n        }\n      }();\n    }\n    function w() {\n      const t = {\n        ...e.diagnosticSdkData\n      };\n      return i.wrapperName && (t.wrapperName = i.wrapperName), i.wrapperVersion && (t.wrapperVersion = i.wrapperVersion), t;\n    }\n    function b() {\n      return {\n        customBaseURI: i.baseUrl !== rt.baseUrl.default,\n        customStreamURI: i.streamUrl !== rt.streamUrl.default,\n        customEventsURI: i.eventsUrl !== rt.eventsUrl.default,\n        eventsCapacity: i.eventCapacity,\n        eventsFlushIntervalMillis: i.flushInterval,\n        reconnectTimeMillis: i.streamReconnectDelay,\n        streamingDisabled: !v,\n        allAttributesPrivate: !!i.allAttributesPrivate,\n        diagnosticRecordingIntervalMillis: i.diagnosticRecordingInterval,\n        usingSecureMode: !!i.hash,\n        bootstrapMode: !!i.bootstrap,\n        fetchGoalsDisabled: !i.fetchGoals,\n        sendEventsOnlyForVariation: !!i.sendEventsOnlyForVariation\n      };\n    }\n    return p.start = () => {\n      s ? function (e) {\n        if (!t.isEnabled()) return e(!1);\n        t.get(c).then(t => {\n          if (t) try {\n            const e = JSON.parse(t);\n            d.setProps(e), f = e.dataSinceDate;\n          } catch (e) {}\n          e(!0);\n        }).catch(() => {\n          e(!1);\n        });\n      }(e => {\n        if (e) {\n          const e = (f || 0) + l,\n            t = new Date().getTime();\n          t >= e ? y() : g = setTimeout(y, e - t);\n        } else 0 === Math.floor(4 * Math.random()) ? y() : g = setTimeout(y, l);\n      }) : (h({\n        kind: \"diagnostic-init\",\n        id: a,\n        creationDate: d.getProps().dataSinceDate,\n        ...m()\n      }), g = setTimeout(y, l));\n    }, p.stop = () => {\n      g && clearTimeout(g);\n    }, p.setStreaming = e => {\n      v = e;\n    }, p;\n  }\n};\nvar at = function (e, t) {\n  let n = !1;\n  const r = {\n    type: e.type,\n    name: e.name,\n    synchronous: e.synchronous,\n    method: function () {\n      try {\n        e.method(...arguments);\n      } catch {\n        n || (n = !0, t.warn(ie.inspectorMethodError(r.type, r.name)));\n      }\n    }\n  };\n  return r;\n};\nconst {\n    onNextTick: st\n  } = S,\n  ct = {\n    flagUsed: \"flag-used\",\n    flagDetailsChanged: \"flag-details-changed\",\n    flagDetailChanged: \"flag-detail-changed\",\n    clientIdentityChanged: \"client-identity-changed\"\n  };\nObject.freeze(ct);\nvar ut = {\n  InspectorTypes: ct,\n  InspectorManager: function (e, t) {\n    const n = {},\n      r = {\n        [ct.flagUsed]: [],\n        [ct.flagDetailsChanged]: [],\n        [ct.flagDetailChanged]: [],\n        [ct.clientIdentityChanged]: []\n      },\n      o = {\n        [ct.flagUsed]: [],\n        [ct.flagDetailsChanged]: [],\n        [ct.flagDetailChanged]: [],\n        [ct.clientIdentityChanged]: []\n      },\n      i = e && e.map(e => at(e, t));\n    return i && i.forEach(e => {\n      Object.prototype.hasOwnProperty.call(r, e.type) && !e.synchronous ? r[e.type].push(e) : Object.prototype.hasOwnProperty.call(o, e.type) && e.synchronous ? o[e.type].push(e) : t.warn(ie.invalidInspector(e.type, e.name));\n    }), n.hasListeners = e => r[e] && r[e].length || o[e] && o[e].length, n.onFlagUsed = (e, t, n) => {\n      const i = ct.flagUsed;\n      o[i].length && o[i].forEach(r => r.method(e, t, n)), r[i].length && st(() => {\n        r[i].forEach(r => r.method(e, t, n));\n      });\n    }, n.onFlags = e => {\n      const t = ct.flagDetailsChanged;\n      o[t].length && o[t].forEach(t => t.method(e)), r[t].length && st(() => {\n        r[t].forEach(t => t.method(e));\n      });\n    }, n.onFlagChanged = (e, t) => {\n      const n = ct.flagDetailChanged;\n      o[n].length && o[n].forEach(n => n.method(e, t)), r[n].length && st(() => {\n        r[n].forEach(n => n.method(e, t));\n      });\n    }, n.onIdentityChanged = e => {\n      const t = ct.clientIdentityChanged;\n      o[t].length && o[t].forEach(t => t.method(e)), r[t].length && st(() => {\n        r[t].forEach(t => t.method(e));\n      });\n    }, n;\n  }\n};\nconst {\n  LDTimeoutError: lt\n} = s;\nvar dt = function (e, t) {\n  return new Promise((n, r) => {\n    setTimeout(() => {\n      r(new lt(`${t} timed out after ${e} seconds.`));\n    }, 1e3 * e);\n  });\n};\nconst {\n    commonBasicLogger: ft\n  } = ne,\n  {\n    checkContext: gt,\n    getContextKeys: vt\n  } = ke,\n  {\n    InspectorTypes: pt,\n    InspectorManager: mt\n  } = ut,\n  ht = \"change\",\n  yt = \"internal-change\";\nvar wt = {\n    initialize: function (e, t, n, r, o) {\n      const i = function () {\n          if (n && n.logger) return n.logger;\n          return o && o.logger && o.logger.default || ft(\"warn\");\n        }(),\n        a = Re(i),\n        c = Ne(a),\n        u = de.validate(n, a, o, i),\n        l = mt(u.inspectors, i),\n        d = u.sendEvents;\n      let f = e,\n        g = u.hash;\n      const v = Ve(r.localStorage, i),\n        p = he(r, f, u),\n        m = u.sendEvents && !u.diagnosticOptOut,\n        h = m ? it.DiagnosticId(f) : null,\n        y = m ? it.DiagnosticsAccumulator(new Date().getTime()) : null,\n        w = m ? it.DiagnosticsManager(r, v, y, p, f, u, h) : null,\n        b = Je(r, u, f, y),\n        k = u.eventProcessor || Ue(r, u, f, y, a, p),\n        E = Qe(r, u, f);\n      let D,\n        x,\n        C,\n        P = {},\n        I = u.streaming,\n        O = !1,\n        T = !1,\n        L = !0;\n      const U = u.stateProvider,\n        R = Ye(null, function (e) {\n          (function (e) {\n            if (U) return;\n            e && F({\n              kind: \"identify\",\n              context: e,\n              creationDate: new Date().getTime()\n            });\n          })(e), l.hasListeners(pt.clientIdentityChanged) && l.onIdentityChanged(R.getContext());\n        }),\n        A = new tt(v),\n        j = v.isEnabled() ? $e(v, f, g, R) : null;\n      function F(e) {\n        f && (U && U.enqueueEvent && U.enqueueEvent(e) || (e.context ? (L = !1, !d || T || r.isDoNotTrack() || (i.debug(ie.debugEnqueueingEvent(e.kind)), k.enqueue(e))) : L && (i.warn(ie.eventWithoutContext()), L = !1)));\n      }\n      function N(e, t) {\n        l.hasListeners(pt.flagDetailChanged) && l.onFlagChanged(e.key, q(t));\n      }\n      function $() {\n        l.hasListeners(pt.flagDetailsChanged) && l.onFlags(Object.entries(P).map(_ref3 => {\n          let [e, t] = _ref3;\n          return {\n            key: e,\n            detail: q(t)\n          };\n        }).reduce((e, t) => (e[t.key] = t.detail, e), {}));\n      }\n      function V(e, t, n, r) {\n        const o = R.getContext(),\n          i = new Date(),\n          a = {\n            kind: \"feature\",\n            key: e,\n            context: o,\n            value: t ? t.value : null,\n            variation: t ? t.variationIndex : null,\n            default: n,\n            creationDate: i.getTime()\n          },\n          s = P[e];\n        s && (a.version = s.flagVersion ? s.flagVersion : s.version, a.trackEvents = s.trackEvents, a.debugEventsUntilDate = s.debugEventsUntilDate), (r || s && s.trackReason) && t && (a.reason = t.reason), F(a);\n      }\n      function M(e) {\n        return gt(e, !1) ? Promise.resolve(e) : Promise.reject(new s.LDInvalidUserError(ie.invalidContext()));\n      }\n      function H(e, t, n, r, o) {\n        let i;\n        if (P && S.objectHasOwnProperty(P, e) && P[e] && !P[e].deleted) {\n          const n = P[e];\n          i = q(n), null !== n.value && void 0 !== n.value || (i.value = t);\n        } else i = {\n          value: t,\n          variationIndex: null,\n          reason: {\n            kind: \"ERROR\",\n            errorKind: \"FLAG_NOT_FOUND\"\n          }\n        };\n        return n && V(e, i, t, r), o || function (e, t) {\n          l.hasListeners(pt.flagUsed) && l.onFlagUsed(e, t, R.getContext());\n        }(e, i), i;\n      }\n      function q(e) {\n        return {\n          value: e.value,\n          variationIndex: void 0 === e.variation ? null : e.variation,\n          reason: e.reason || null\n        };\n      }\n      function z() {\n        if (x = !0, !R.getContext()) return;\n        const e = e => {\n          try {\n            return JSON.parse(e);\n          } catch (e) {\n            return void a.maybeReportError(new s.LDInvalidDataError(ie.invalidData()));\n          }\n        };\n        b.connect(R.getContext(), g, {\n          ping: function () {\n            i.debug(ie.debugStreamPing());\n            const e = R.getContext();\n            E.fetchFlagSettings(e, g).then(t => {\n              S.deepEquals(e, R.getContext()) && _(t || {});\n            }).catch(e => {\n              a.maybeReportError(new s.LDFlagFetchError(ie.errorFetchingFlags(e)));\n            });\n          },\n          put: function (t) {\n            const n = e(t.data);\n            n && (i.debug(ie.debugStreamPut()), _(n));\n          },\n          patch: function (t) {\n            const n = e(t.data);\n            if (!n) return;\n            const r = P[n.key];\n            if (!r || !r.version || !n.version || r.version < n.version) {\n              i.debug(ie.debugStreamPatch(n.key));\n              const e = {},\n                t = S.extend({}, n);\n              delete t.key, P[n.key] = t;\n              const o = q(t);\n              e[n.key] = r ? {\n                previous: r.value,\n                current: o\n              } : {\n                current: o\n              }, N(n, t), J(e);\n            } else i.debug(ie.debugStreamPatchIgnored(n.key));\n          },\n          delete: function (t) {\n            const n = e(t.data);\n            if (n) if (!P[n.key] || P[n.key].version < n.version) {\n              i.debug(ie.debugStreamDelete(n.key));\n              const e = {};\n              P[n.key] && !P[n.key].deleted && (e[n.key] = {\n                previous: P[n.key].value\n              }), P[n.key] = {\n                version: n.version,\n                deleted: !0\n              }, N(n, P[n.key]), J(e);\n            } else i.debug(ie.debugStreamDeleteIgnored(n.key));\n          }\n        });\n      }\n      function K() {\n        x && (b.disconnect(), x = !1);\n      }\n      function _(e) {\n        const t = {};\n        if (!e) return Promise.resolve();\n        for (const n in P) S.objectHasOwnProperty(P, n) && P[n] && (e[n] && !S.deepEquals(e[n].value, P[n].value) ? t[n] = {\n          previous: P[n].value,\n          current: q(e[n])\n        } : e[n] && !e[n].deleted || (t[n] = {\n          previous: P[n].value\n        }));\n        for (const n in e) S.objectHasOwnProperty(e, n) && e[n] && (!P[n] || P[n].deleted) && (t[n] = {\n          current: q(e[n])\n        });\n        return P = {\n          ...e\n        }, $(), J(t).catch(() => {});\n      }\n      function J(e) {\n        const t = Object.keys(e);\n        if (t.length > 0) {\n          const n = {};\n          t.forEach(t => {\n            const r = e[t].current,\n              o = r ? r.value : void 0,\n              i = e[t].previous;\n            a.emit(ht + \":\" + t, o, i), n[t] = r ? {\n              current: o,\n              previous: i\n            } : {\n              previous: i\n            };\n          }), a.emit(ht, n), a.emit(yt, P), u.sendEventsOnlyForVariation || U || t.forEach(t => {\n            V(t, e[t].current);\n          });\n        }\n        return D && j ? j.saveFlags(P) : Promise.resolve();\n      }\n      function B() {\n        const e = I || C && void 0 === I;\n        e && !x ? z() : !e && x && K(), w && w.setStreaming(e);\n      }\n      function G(e) {\n        return e === ht || e.substr(0, 7) === ht + \":\";\n      }\n      if (\"string\" == typeof u.bootstrap && \"LOCALSTORAGE\" === u.bootstrap.toUpperCase() && (j ? D = !0 : i.warn(ie.localStorageUnavailable())), \"object\" == typeof u.bootstrap && (P = function (e) {\n        const t = Object.keys(e),\n          n = \"$flagsState\",\n          r = \"$valid\",\n          o = e[n];\n        !o && t.length && i.warn(ie.bootstrapOldFormat()), !1 === e[r] && i.warn(ie.bootstrapInvalid());\n        const a = {};\n        return t.forEach(t => {\n          if (t !== n && t !== r) {\n            let n = {\n              value: e[t]\n            };\n            o && o[t] ? n = S.extend(n, o[t]) : n.version = 0, a[t] = n;\n          }\n        }), a;\n      }(u.bootstrap)), U) {\n        const e = U.getInitialState();\n        e ? W(e) : U.on(\"init\", W), U.on(\"update\", function (e) {\n          e.context && R.setContext(e.context);\n          e.flags && _(e.flags);\n        });\n      } else (function () {\n        if (!e) return Promise.reject(new s.LDInvalidEnvironmentIdError(ie.environmentNotSpecified()));\n        return A.processContext(t).then(M).then(e => (R.setContext(e), \"object\" == typeof u.bootstrap ? X() : D ? j.loadFlags().then(e => null == e ? (P = {}, E.fetchFlagSettings(R.getContext(), g).then(e => _(e || {})).then(X).catch(e => {\n          Q(new s.LDFlagFetchError(ie.errorFetchingFlags(e)));\n        })) : (P = e, S.onNextTick(X), E.fetchFlagSettings(R.getContext(), g).then(e => _(e)).catch(e => a.maybeReportError(e)))) : E.fetchFlagSettings(R.getContext(), g).then(e => {\n          P = e || {}, $(), X();\n        }).catch(e => {\n          P = {}, Q(e);\n        })));\n      })().catch(Q);\n      function W(e) {\n        f = e.environment, R.setContext(e.context), P = {\n          ...e.flags\n        }, S.onNextTick(X);\n      }\n      function X() {\n        i.info(ie.clientInitialized()), O = !0, B(), c.signalSuccess();\n      }\n      function Q(e) {\n        c.signalFailure(e);\n      }\n      const Y = {\n        waitForInitialization: function () {\n          let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : void 0;\n          if (null != e) {\n            if (\"number\" == typeof e) return function (e) {\n              e > 5 && i.warn(\"The waitForInitialization function was called with a timeout greater than 5 seconds. We recommend a timeout of 5 seconds or less.\");\n              const t = c.getInitializationPromise(),\n                n = dt(e, \"waitForInitialization\");\n              return Promise.race([n, t]).catch(e => {\n                throw e instanceof s.LDTimeoutError && i.error(`waitForInitialization error: ${e}`), e;\n              });\n            }(e);\n            i.warn(\"The waitForInitialization method was provided with a non-numeric timeout.\");\n          }\n          return i.warn(\"The waitForInitialization function was called without a timeout specified. In a future version a default timeout will be applied.\"), c.getInitializationPromise();\n        },\n        waitUntilReady: () => c.getReadyPromise(),\n        identify: function (e, t, n) {\n          if (T) return S.wrapPromiseCallback(Promise.resolve({}), n);\n          if (U) return i.warn(ie.identifyDisabled()), S.wrapPromiseCallback(Promise.resolve(S.transformVersionedValuesToValues(P)), n);\n          const r = D && j ? j.clearFlags() : Promise.resolve();\n          return S.wrapPromiseCallback(r.then(() => A.processContext(e)).then(M).then(e => E.fetchFlagSettings(e, t).then(n => {\n            const r = S.transformVersionedValuesToValues(n);\n            return R.setContext(e), g = t, n ? _(n).then(() => r) : r;\n          })).then(e => (x && z(), e)).catch(e => (a.maybeReportError(e), Promise.reject(e))), n);\n        },\n        getContext: function () {\n          return R.getContext();\n        },\n        variation: function (e, t) {\n          return H(e, t, !0, !1, !1).value;\n        },\n        variationDetail: function (e, t) {\n          return H(e, t, !0, !0, !1);\n        },\n        track: function (e, t, n) {\n          if (\"string\" != typeof e) return void a.maybeReportError(new s.LDInvalidEventKeyError(ie.unknownCustomEventKey(e)));\n          void 0 !== n && \"number\" != typeof n && i.warn(ie.invalidMetricValue(typeof n)), r.customEventFilter && !r.customEventFilter(e) && i.warn(ie.unknownCustomEventKey(e));\n          const o = R.getContext(),\n            c = {\n              kind: \"custom\",\n              key: e,\n              context: o,\n              url: r.getCurrentUrl(),\n              creationDate: new Date().getTime()\n            };\n          o && o.anonymous && (c.contextKind = o.anonymous ? \"anonymousUser\" : \"user\"), null != t && (c.data = t), null != n && (c.metricValue = n), F(c);\n        },\n        on: function (e, t, n) {\n          G(e) ? (C = !0, O && B(), a.on(e, t, n)) : a.on(...arguments);\n        },\n        off: function (e) {\n          if (a.off(...arguments), G(e)) {\n            let e = !1;\n            a.getEvents().forEach(t => {\n              G(t) && a.getEventListenerCount(t) > 0 && (e = !0);\n            }), e || (C = !1, x && void 0 === I && K());\n          }\n        },\n        setStreaming: function (e) {\n          const t = null === e ? void 0 : e;\n          t !== I && (I = t, B());\n        },\n        flush: function (e) {\n          return S.wrapPromiseCallback(d ? k.flush() : Promise.resolve(), e);\n        },\n        allFlags: function () {\n          const e = {};\n          if (!P) return e;\n          for (const t in P) S.objectHasOwnProperty(P, t) && !P[t].deleted && (e[t] = H(t, null, !u.sendEventsOnlyForVariation, !1, !0).value);\n          return e;\n        },\n        close: function (e) {\n          if (T) return S.wrapPromiseCallback(Promise.resolve(), e);\n          const t = () => {\n              T = !0, P = {};\n            },\n            n = Promise.resolve().then(() => {\n              if (K(), w && w.stop(), d) return k.stop(), k.flush();\n            }).then(t).catch(t);\n          return S.wrapPromiseCallback(n, e);\n        }\n      };\n      return {\n        client: Y,\n        options: u,\n        emitter: a,\n        ident: R,\n        logger: i,\n        requestor: E,\n        start: function () {\n          d && (w && w.start(), k.start());\n        },\n        enqueueEvent: F,\n        getFlagsInternal: function () {\n          return P;\n        },\n        getEnvironmentId: () => f,\n        internalChangeEventName: yt\n      };\n    },\n    commonBasicLogger: ft,\n    errors: s,\n    messages: ie,\n    utils: S,\n    getContextKeys: vt\n  },\n  bt = wt.initialize,\n  kt = wt.errors,\n  Et = wt.messages;\nfunction Dt(e, t, n) {\n  return (t = function (e) {\n    var t = function (e, t) {\n      if (\"object\" != typeof e || !e) return e;\n      var n = e[Symbol.toPrimitive];\n      if (void 0 !== n) {\n        var r = n.call(e, t || \"default\");\n        if (\"object\" != typeof r) return r;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n      }\n      return (\"string\" === t ? String : Number)(e);\n    }(e, \"string\");\n    return \"symbol\" == typeof t ? t : t + \"\";\n  }(t)) in e ? Object.defineProperty(e, t, {\n    value: n,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[t] = n, e;\n}\nfunction xt(e, t) {\n  var n = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var r = Object.getOwnPropertySymbols(e);\n    t && (r = r.filter(function (t) {\n      return Object.getOwnPropertyDescriptor(e, t).enumerable;\n    })), n.push.apply(n, r);\n  }\n  return n;\n}\nfunction Ct(e) {\n  for (var t = 1; t < arguments.length; t++) {\n    var n = null != arguments[t] ? arguments[t] : {};\n    t % 2 ? xt(Object(n), !0).forEach(function (t) {\n      Dt(e, t, n[t]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : xt(Object(n)).forEach(function (t) {\n      Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t));\n    });\n  }\n  return e;\n}\nvar Pt = wt.commonBasicLogger;\nvar St = function (e) {\n  return Pt(Ct({\n    destination: console.log\n  }, e));\n};\nvar It = {\n  promise: Promise.resolve({\n    status: 200,\n    header: function () {\n      return null;\n    },\n    body: null\n  })\n};\nfunction Ot(e, t, n, r, o) {\n  if (o && !function () {\n    var e = window.navigator && window.navigator.userAgent;\n    if (e) {\n      var t = e.match(/Chrom(e|ium)\\/([0-9]+)\\./);\n      if (t) return parseInt(t[2], 10) < 73;\n    }\n    return !0;\n  }()) return It;\n  var i = new window.XMLHttpRequest();\n  for (var a in i.open(e, t, !o), n || {}) Object.prototype.hasOwnProperty.call(n, a) && i.setRequestHeader(a, n[a]);\n  if (o) {\n    try {\n      i.send(r);\n    } catch (e) {}\n    return It;\n  }\n  var s,\n    c = new Promise(function (e, t) {\n      i.addEventListener(\"load\", function () {\n        s || e({\n          status: i.status,\n          header: function (e) {\n            return i.getResponseHeader(e);\n          },\n          body: i.responseText\n        });\n      }), i.addEventListener(\"error\", function () {\n        s || t(new Error());\n      }), i.send(r);\n    });\n  return {\n    promise: c,\n    cancel: function () {\n      s = !0, i.abort();\n    }\n  };\n}\nvar Tt = e => {\n  if (\"string\" != typeof e) throw new TypeError(\"Expected a string\");\n  return e.replace(/[|\\\\{}()[\\]^$+*?.]/g, \"\\\\$&\").replace(/-/g, \"\\\\x2d\");\n};\nfunction Lt(e, t, n, r) {\n  var o,\n    i,\n    a = ((\"substring\" === e.kind || \"regex\" === e.kind) && r.includes(\"/\") ? t : t.replace(r, \"\")).replace(n, \"\");\n  switch (e.kind) {\n    case \"exact\":\n      i = t, o = new RegExp(\"^\" + Tt(e.url) + \"/?$\");\n      break;\n    case \"canonical\":\n      i = a, o = new RegExp(\"^\" + Tt(e.url) + \"/?$\");\n      break;\n    case \"substring\":\n      i = a, o = new RegExp(\".*\" + Tt(e.substring) + \".*$\");\n      break;\n    case \"regex\":\n      i = a, o = new RegExp(e.pattern);\n      break;\n    default:\n      return !1;\n  }\n  return o.test(i);\n}\nfunction Ut(e, t) {\n  for (var n = {}, r = null, o = [], i = 0; i < e.length; i++) for (var a = e[i], s = a.urls || [], c = 0; c < s.length; c++) if (Lt(s[c], window.location.href, window.location.search, window.location.hash)) {\n    \"pageview\" === a.kind ? t(\"pageview\", a) : (o.push(a), t(\"click_pageview\", a));\n    break;\n  }\n  return o.length > 0 && (r = function (e) {\n    for (var n = function (e, t) {\n        for (var n = [], r = 0; r < t.length; r++) for (var o = e.target, i = t[r], a = i.selector, s = document.querySelectorAll(a); o && s.length > 0;) {\n          for (var c = 0; c < s.length; c++) o === s[c] && n.push(i);\n          o = o.parentNode;\n        }\n        return n;\n      }(e, o), r = 0; r < n.length; r++) t(\"click\", n[r]);\n  }, document.addEventListener(\"click\", r)), n.dispose = function () {\n    document.removeEventListener(\"click\", r);\n  }, n;\n}\nvar Rt = 300;\nfunction At(e, t) {\n  var n, r;\n  function o() {\n    r && r.dispose(), n && n.length && (r = Ut(n, i));\n  }\n  function i(t, n) {\n    var r = e.ident.getContext(),\n      o = {\n        kind: t,\n        key: n.key,\n        data: null,\n        url: window.location.href,\n        creationDate: new Date().getTime(),\n        context: r\n      };\n    return \"click\" === t && (o.selector = n.selector), e.enqueueEvent(o);\n  }\n  return e.requestor.fetchJSON(\"/sdk/goals/\" + e.getEnvironmentId()).then(function (e) {\n    e && e.length > 0 && (r = Ut(n = e, i), function (e, t) {\n      var n,\n        r = window.location.href;\n      function o() {\n        (n = window.location.href) !== r && (r = n, t());\n      }\n      !function e(t, n) {\n        t(), setTimeout(function () {\n          e(t, n);\n        }, n);\n      }(o, e), window.history && window.history.pushState ? window.addEventListener(\"popstate\", o) : window.addEventListener(\"hashchange\", o);\n    }(Rt, o)), t();\n  }).catch(function (n) {\n    e.emitter.maybeReportError(new kt.LDUnexpectedResponseError((n && n.message, n.message))), t();\n  }), {};\n}\nvar jt = \"goalsReady\",\n  Ft = {\n    fetchGoals: {\n      default: !0\n    },\n    hash: {\n      type: \"string\"\n    },\n    eventProcessor: {\n      type: \"object\"\n    },\n    eventUrlTransformer: {\n      type: \"function\"\n    },\n    disableSyncEventPost: {\n      default: !1\n    }\n  };\nfunction Nt(e, t) {\n  var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},\n    r = function (e) {\n      var t,\n        n = {\n          userAgentHeaderName: \"X-LaunchDarkly-User-Agent\",\n          synchronousFlush: !1\n        };\n      if (window.XMLHttpRequest) {\n        var r = e && e.disableSyncEventPost;\n        n.httpRequest = function (e, t, o, i) {\n          var a = n.synchronousFlush & !r;\n          return n.synchronousFlush = !1, Ot(e, t, o, i, a);\n        };\n      }\n      n.httpAllowsPost = function () {\n        return void 0 === t && (t = !!window.XMLHttpRequest && \"withCredentials\" in new window.XMLHttpRequest()), t;\n      }, n.httpFallbackPing = function (e) {\n        new window.Image().src = e;\n      };\n      var o,\n        i = e && e.eventUrlTransformer;\n      n.getCurrentUrl = function () {\n        return i ? i(window.location.href) : window.location.href;\n      }, n.isDoNotTrack = function () {\n        var e;\n        return 1 === (e = window.navigator && void 0 !== window.navigator.doNotTrack ? window.navigator.doNotTrack : window.navigator && void 0 !== window.navigator.msDoNotTrack ? window.navigator.msDoNotTrack : window.doNotTrack) || !0 === e || \"1\" === e || \"yes\" === e;\n      };\n      try {\n        window.localStorage && (n.localStorage = {\n          get: function (e) {\n            return new Promise(function (t) {\n              t(window.localStorage.getItem(e));\n            });\n          },\n          set: function (e, t) {\n            return new Promise(function (n) {\n              window.localStorage.setItem(e, t), n();\n            });\n          },\n          clear: function (e) {\n            return new Promise(function (t) {\n              window.localStorage.removeItem(e), t();\n            });\n          }\n        });\n      } catch (e) {\n        n.localStorage = null;\n      }\n      if (e && e.useReport && \"function\" == typeof window.EventSourcePolyfill && window.EventSourcePolyfill.supportedOptions && window.EventSourcePolyfill.supportedOptions.method ? (n.eventSourceAllowsReport = !0, o = window.EventSourcePolyfill) : (n.eventSourceAllowsReport = !1, o = window.EventSource), window.EventSource) {\n        var a = 3e5;\n        n.eventSourceFactory = function (e, t) {\n          var n = Ct(Ct({}, {\n            heartbeatTimeout: a,\n            silentTimeout: a,\n            skipDefaultHeaders: !0\n          }), t);\n          return new o(e, n);\n        }, n.eventSourceIsActive = function (e) {\n          return e.readyState === window.EventSource.OPEN || e.readyState === window.EventSource.CONNECTING;\n        };\n      }\n      return n.userAgent = \"JSClient\", n.version = \"3.4.0\", n.diagnosticSdkData = {\n        name: \"js-client-sdk\",\n        version: \"3.4.0\"\n      }, n.diagnosticPlatformData = {\n        name: \"JS\"\n      }, n.diagnosticUseCombinedEvent = !0, n;\n    }(n),\n    o = bt(e, t, n, r, Ft),\n    i = o.client,\n    a = o.options,\n    s = o.emitter,\n    c = new Promise(function (e) {\n      var t = s.on(jt, function () {\n        s.off(jt, t), e();\n      });\n    });\n  i.waitUntilGoalsReady = function () {\n    return c;\n  }, a.fetchGoals ? At(o, function () {\n    return s.emit(jt);\n  }) : s.emit(jt), \"complete\" !== document.readyState ? window.addEventListener(\"load\", o.start) : o.start();\n  var u = function () {\n    r.synchronousFlush = !0, i.flush().catch(function () {}), r.synchronousFlush = !1;\n  };\n  return document.addEventListener(\"visibilitychange\", function () {\n    \"hidden\" === document.visibilityState && u();\n  }), window.addEventListener(\"pagehide\", u), i;\n}\nvar $t = St,\n  Vt = void 0,\n  Mt = \"3.4.0\";\nvar Ht = {\n  initialize: function (e, t) {\n    var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};\n    return console && console.warn && console.warn(Et.deprecated(\"default export\", \"named LDClient export\")), Nt(e, t, n);\n  },\n  version: Mt\n};\nexport { $t as basicLogger, Vt as createConsoleLogger, Ht as default, Nt as initialize, Mt as version };","map":{"version":3,"names":["e","t","Error","captureStackTrace","constructor","message","code","prototype","name","n","r","o","i","a","s","LDUnexpectedResponseError","LDInvalidEnvironmentIdError","LDInvalidUserError","LDInvalidEventKeyError","LDInvalidArgumentError","LDInvalidDataError","LDFlagFetchError","LDTimeoutError","isHttpErrorRecoverable","c","byteLength_1","m","u","toByteArray_1","g","f","charCodeAt","l","fromByteArray_1","length","push","h","d","join","Uint8Array","Array","v","p","indexOf","y","byteLength","toByteArray","fromByteArray","w","isArray","b","Object","keys","k","hasOwnProperty","E","Date","getTime","RegExp","toString","call","D","x","unescape","encodeURIComponent","C","P","S","appendUrlPath","endsWith","substring","startsWith","base64URLEncode","replace","btoa","clone","JSON","parse","stringify","deepEquals","extend","_len","arguments","_key","reduce","getLDUserAgentString","version","userAgent","objectHasOwnProperty","onNextTick","setTimeout","sanitizeContext","kind","forEach","String","transformValuesToVersionedValues","value","transformVersionedValuesToValues","wrapPromiseCallback","then","Promise","reject","I","O","crypto","getRandomValues","bind","msCrypto","T","L","test","U","R","A","j","substr","F","toLowerCase","TypeError","N","$","V","parseInt","slice","M","set","DNS","URL","H","q","z","K","_","J","B","G","charAt","Uint32Array","W","X","Q","Y","Math","ceil","pow","floor","Z","ee","freeze","__proto__","v1","v5","node","clockseq","random","rng","msecs","now","nsecs","v3","v4","NIL","validate","te","ne","commonBasicLogger","destination","console","prefix","level","log","validateLogger","re","oe","ie","bootstrapInvalid","bootstrapOldFormat","clientInitialized","clientNotReady","debugEnqueueingEvent","debugPostingDiagnosticEvent","debugPostingEvents","debugStreamDelete","debugStreamDeleteIgnored","debugStreamPatch","debugStreamPatchIgnored","debugStreamPing","debugPolling","debugStreamPut","deprecated","environmentNotFound","environmentNotSpecified","errorFetchingFlags","eventCapacityExceeded","eventWithoutContext","httpErrorMessage","httpUnavailable","identifyDisabled","inspectorMethodError","invalidContentType","invalidData","invalidInspector","invalidKey","invalidMetricValue","invalidContext","invalidTagValue","localStorageUnavailable","networkError","optionBelowMinimum","streamClosing","streamConnecting","streamError","tagValueTooLong","unknownCustomEventKey","unknownOption","contextNotSpecified","unrecoverableStreamError","wrongOptionType","wrongOptionTypeBoolean","ae","se","baseUrl","default","streamUrl","eventsUrl","sendEvents","streaming","type","sendLDHeaders","requestHeaderTransform","sendEventsOnlyForVariation","useReport","evaluationReasons","eventCapacity","minimum","flushInterval","samplingInterval","streamReconnectDelay","allAttributesPrivate","privateAttributes","bootstrap","diagnosticRecordingInterval","diagnosticOptOut","wrapperName","wrapperVersion","stateProvider","application","validator","id","le","inspectors","ce","ue","match","warn","de","baseOptionDefs","logger","maybeReportError","split","getTags","fe","ge","getLDHeaders","userAgentHeaderName","sort","map","concat","transformHeaders","ve","pe","me","he","EventSender_1","httpRequest","resolve","promise","status","header","serverTime","catch","ye","we","be","includes","ke","checkContext","key","filter","every","getContextKeys","undefined","user","entries","_ref","_ref2","getContextKinds","getCanonicalKey","Ee","De","EventSummarizer_1","summarizeEvent","variation","Set","context","contextKeys","add","count","creationDate","getSummary","values","counters","contextKinds","unknown","startDate","endDate","features","clearSummary","xe","Ce","Pe","Se","Ie","Oe","cloneExcluding","ptr","source","parent","visited","pop","some","cloned","excluded","compare","literalToReference","Te","ContextFilter_1","filterSingleKind","anonymous","_meta","redactedAttributes","custom","privateAttributeNames","Le","Ue","EventProcessor_1","trackEvents","debugEventsUntilDate","incrementDroppedEvents","enqueue","flush","setEventsInLastBatch","debug","start","flushTick","stop","clearTimeout","Re","EventEmitter_1","on","handler","off","emit","apply","getEvents","getEventListenerCount","error","Ae","je","Fe","Ne","InitializationState","onReady","getInitializationPromise","onSuccess","getReadyPromise","signalSuccess","signalFailure","$e","PersistentFlagStore_1","getContext","loadFlags","get","$schema","clearFlags","saveFlags","clear","Ve","PersistentStorage_1","isEnabled","Me","He","qe","ze","Ke","_e","Je","Stream_1","trunc","headers","readTimeoutMillis","eventSourceFactory","eventSourceAllowsReport","method","body","info","addEventListener","onerror","onopen","close","recordStreamInit","connect","disconnect","isConnected","eventSourceIsActive","Be","promiseCoalescer_1","addPromise","coalescer","resultPromise","Ge","We","Xe","Qe","Requestor_1","statusText","cancel","fetchJSON","fetchFlagSettings","Ye","Identity_1","setContext","Ze","et","tt","AnonymousContextProcessor_1","processContext","all","nt","rt","ot","it","DiagnosticId","diagnosticId","sdkKeySuffix","DiagnosticsAccumulator","getProps","dataSinceDate","droppedEvents","eventsInLastBatch","streamInits","setProps","timestamp","failed","durationMillis","reset","DiagnosticsManager","diagnosticUseCombinedEvent","sdk","configuration","platform","diagnosticPlatformData","diagnosticSdkData","customBaseURI","customStreamURI","customEventsURI","eventsCapacity","eventsFlushIntervalMillis","reconnectTimeMillis","streamingDisabled","diagnosticRecordingIntervalMillis","usingSecureMode","hash","bootstrapMode","fetchGoalsDisabled","fetchGoals","setStreaming","at","SafeInspector_1","synchronous","wrapper","st","ct","flagUsed","flagDetailsChanged","flagDetailChanged","clientIdentityChanged","ut","InspectorTypes","InspectorManager","hasListeners","onFlagUsed","onFlags","onFlagChanged","onIdentityChanged","lt","dt","timedPromise_1","ft","gt","vt","pt","mt","ht","yt","wt","initialize","localStorage","eventProcessor","enqueueEvent","isDoNotTrack","_ref3","detail","variationIndex","flagVersion","trackReason","reason","deleted","errorKind","ping","put","data","patch","previous","current","delete","toUpperCase","getInitialState","flags","environment","waitForInitialization","race","waitUntilReady","identify","variationDetail","track","customEventFilter","url","getCurrentUrl","contextKind","metricValue","allFlags","finishClose","client","options","emitter","ident","requestor","getFlagsInternal","getEnvironmentId","internalChangeEventName","errors","messages","utils","bt","kt","Et","Dt","Symbol","toPrimitive","Number","defineProperty","enumerable","configurable","writable","xt","getOwnPropertySymbols","getOwnPropertyDescriptor","Ct","getOwnPropertyDescriptors","defineProperties","Pt","St","It","Ot","window","navigator","XMLHttpRequest","open","setRequestHeader","send","getResponseHeader","responseText","abort","Tt","Lt","pattern","Ut","urls","location","href","search","listenerFn","target","selector","document","querySelectorAll","parentNode","dispose","removeEventListener","Rt","At","history","pushState","jt","Ft","eventUrlTransformer","disableSyncEventPost","Nt","synchronousFlush","httpAllowsPost","httpFallbackPing","Image","src","doNotTrack","msDoNotTrack","getItem","setItem","removeItem","EventSourcePolyfill","supportedOptions","EventSource","heartbeatTimeout","silentTimeout","skipDefaultHeaders","readyState","OPEN","CONNECTING","waitUntilGoalsReady","syncFlush","visibilityState","$t","Vt","Mt","Ht","basicLogger","createConsoleLogger"],"sources":["/Users/sfalzon/Github/ld-multidemo/node_modules/launchdarkly-js-client-sdk/node_modules/launchdarkly-js-sdk-common/src/errors.js","/Users/sfalzon/Github/ld-multidemo/node_modules/launchdarkly-js-client-sdk/node_modules/base64-js/index.js","/Users/sfalzon/Github/ld-multidemo/node_modules/launchdarkly-js-client-sdk/node_modules/fast-deep-equal/index.js","/Users/sfalzon/Github/ld-multidemo/node_modules/launchdarkly-js-client-sdk/node_modules/launchdarkly-js-sdk-common/src/utils.js","/Users/sfalzon/Github/ld-multidemo/node_modules/launchdarkly-js-client-sdk/node_modules/uuid/dist/esm-browser/rng.js","/Users/sfalzon/Github/ld-multidemo/node_modules/launchdarkly-js-client-sdk/node_modules/uuid/dist/esm-browser/regex.js","/Users/sfalzon/Github/ld-multidemo/node_modules/launchdarkly-js-client-sdk/node_modules/uuid/dist/esm-browser/validate.js","/Users/sfalzon/Github/ld-multidemo/node_modules/launchdarkly-js-client-sdk/node_modules/uuid/dist/esm-browser/stringify.js","/Users/sfalzon/Github/ld-multidemo/node_modules/launchdarkly-js-client-sdk/node_modules/uuid/dist/esm-browser/v1.js","/Users/sfalzon/Github/ld-multidemo/node_modules/launchdarkly-js-client-sdk/node_modules/uuid/dist/esm-browser/parse.js","/Users/sfalzon/Github/ld-multidemo/node_modules/launchdarkly-js-client-sdk/node_modules/uuid/dist/esm-browser/v35.js","/Users/sfalzon/Github/ld-multidemo/node_modules/launchdarkly-js-client-sdk/node_modules/uuid/dist/esm-browser/md5.js","/Users/sfalzon/Github/ld-multidemo/node_modules/launchdarkly-js-client-sdk/node_modules/uuid/dist/esm-browser/v3.js","/Users/sfalzon/Github/ld-multidemo/node_modules/launchdarkly-js-client-sdk/node_modules/uuid/dist/esm-browser/sha1.js","/Users/sfalzon/Github/ld-multidemo/node_modules/launchdarkly-js-client-sdk/node_modules/uuid/dist/esm-browser/v5.js","/Users/sfalzon/Github/ld-multidemo/node_modules/launchdarkly-js-client-sdk/node_modules/uuid/dist/esm-browser/v4.js","/Users/sfalzon/Github/ld-multidemo/node_modules/launchdarkly-js-client-sdk/node_modules/uuid/dist/esm-browser/nil.js","/Users/sfalzon/Github/ld-multidemo/node_modules/launchdarkly-js-client-sdk/node_modules/uuid/dist/esm-browser/version.js","/Users/sfalzon/Github/ld-multidemo/node_modules/launchdarkly-js-client-sdk/node_modules/launchdarkly-js-sdk-common/src/loggers.js","/Users/sfalzon/Github/ld-multidemo/node_modules/launchdarkly-js-client-sdk/node_modules/launchdarkly-js-sdk-common/src/messages.js","/Users/sfalzon/Github/ld-multidemo/node_modules/launchdarkly-js-client-sdk/node_modules/launchdarkly-js-sdk-common/src/configuration.js","/Users/sfalzon/Github/ld-multidemo/node_modules/launchdarkly-js-client-sdk/node_modules/launchdarkly-js-sdk-common/src/headers.js","/Users/sfalzon/Github/ld-multidemo/node_modules/launchdarkly-js-client-sdk/node_modules/launchdarkly-js-sdk-common/src/EventSender.js","/Users/sfalzon/Github/ld-multidemo/node_modules/launchdarkly-js-client-sdk/node_modules/launchdarkly-js-sdk-common/src/context.js","/Users/sfalzon/Github/ld-multidemo/node_modules/launchdarkly-js-client-sdk/node_modules/launchdarkly-js-sdk-common/src/EventSummarizer.js","/Users/sfalzon/Github/ld-multidemo/node_modules/launchdarkly-js-client-sdk/node_modules/launchdarkly-js-sdk-common/src/attributeReference.js","/Users/sfalzon/Github/ld-multidemo/node_modules/launchdarkly-js-client-sdk/node_modules/launchdarkly-js-sdk-common/src/ContextFilter.js","/Users/sfalzon/Github/ld-multidemo/node_modules/launchdarkly-js-client-sdk/node_modules/launchdarkly-js-sdk-common/src/EventProcessor.js","/Users/sfalzon/Github/ld-multidemo/node_modules/launchdarkly-js-client-sdk/node_modules/launchdarkly-js-sdk-common/src/EventEmitter.js","/Users/sfalzon/Github/ld-multidemo/node_modules/launchdarkly-js-client-sdk/node_modules/launchdarkly-js-sdk-common/src/InitializationState.js","/Users/sfalzon/Github/ld-multidemo/node_modules/launchdarkly-js-client-sdk/node_modules/launchdarkly-js-sdk-common/src/PersistentFlagStore.js","/Users/sfalzon/Github/ld-multidemo/node_modules/launchdarkly-js-client-sdk/node_modules/launchdarkly-js-sdk-common/src/PersistentStorage.js","/Users/sfalzon/Github/ld-multidemo/node_modules/launchdarkly-js-client-sdk/node_modules/launchdarkly-js-sdk-common/src/Stream.js","/Users/sfalzon/Github/ld-multidemo/node_modules/launchdarkly-js-client-sdk/node_modules/launchdarkly-js-sdk-common/src/promiseCoalescer.js","/Users/sfalzon/Github/ld-multidemo/node_modules/launchdarkly-js-client-sdk/node_modules/launchdarkly-js-sdk-common/src/Requestor.js","/Users/sfalzon/Github/ld-multidemo/node_modules/launchdarkly-js-client-sdk/node_modules/launchdarkly-js-sdk-common/src/Identity.js","/Users/sfalzon/Github/ld-multidemo/node_modules/launchdarkly-js-client-sdk/node_modules/launchdarkly-js-sdk-common/src/AnonymousContextProcessor.js","/Users/sfalzon/Github/ld-multidemo/node_modules/launchdarkly-js-client-sdk/node_modules/launchdarkly-js-sdk-common/src/diagnosticEvents.js","/Users/sfalzon/Github/ld-multidemo/node_modules/launchdarkly-js-client-sdk/node_modules/launchdarkly-js-sdk-common/src/SafeInspector.js","/Users/sfalzon/Github/ld-multidemo/node_modules/launchdarkly-js-client-sdk/node_modules/launchdarkly-js-sdk-common/src/InspectorManager.js","/Users/sfalzon/Github/ld-multidemo/node_modules/launchdarkly-js-client-sdk/node_modules/launchdarkly-js-sdk-common/src/timedPromise.js","/Users/sfalzon/Github/ld-multidemo/node_modules/launchdarkly-js-client-sdk/node_modules/launchdarkly-js-sdk-common/src/index.js","/Users/sfalzon/Github/ld-multidemo/node_modules/launchdarkly-js-client-sdk/src/basicLogger.js","/Users/sfalzon/Github/ld-multidemo/node_modules/launchdarkly-js-client-sdk/src/httpRequest.js","/Users/sfalzon/Github/ld-multidemo/node_modules/launchdarkly-js-client-sdk/node_modules/escape-string-regexp/index.js","/Users/sfalzon/Github/ld-multidemo/node_modules/launchdarkly-js-client-sdk/src/GoalTracker.js","/Users/sfalzon/Github/ld-multidemo/node_modules/launchdarkly-js-client-sdk/src/GoalManager.js","/Users/sfalzon/Github/ld-multidemo/node_modules/launchdarkly-js-client-sdk/src/index.js","/Users/sfalzon/Github/ld-multidemo/node_modules/launchdarkly-js-client-sdk/src/browserPlatform.js"],"sourcesContent":["function createCustomError(name) {\n  function CustomError(message, code) {\n    Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);\n    this.message = message;\n    this.code = code;\n  }\n\n  CustomError.prototype = new Error();\n  CustomError.prototype.name = name;\n  CustomError.prototype.constructor = CustomError;\n\n  return CustomError;\n}\n\nconst LDUnexpectedResponseError = createCustomError('LaunchDarklyUnexpectedResponseError');\nconst LDInvalidEnvironmentIdError = createCustomError('LaunchDarklyInvalidEnvironmentIdError');\nconst LDInvalidUserError = createCustomError('LaunchDarklyInvalidUserError');\nconst LDInvalidEventKeyError = createCustomError('LaunchDarklyInvalidEventKeyError');\nconst LDInvalidArgumentError = createCustomError('LaunchDarklyInvalidArgumentError');\nconst LDFlagFetchError = createCustomError('LaunchDarklyFlagFetchError');\nconst LDInvalidDataError = createCustomError('LaunchDarklyInvalidDataError');\nconst LDTimeoutError = createCustomError('LaunchDarklyTimeoutError');\n\nfunction isHttpErrorRecoverable(status) {\n  if (status >= 400 && status < 500) {\n    return status === 400 || status === 408 || status === 429;\n  }\n  return true;\n}\n\nmodule.exports = {\n  LDUnexpectedResponseError,\n  LDInvalidEnvironmentIdError,\n  LDInvalidUserError,\n  LDInvalidEventKeyError,\n  LDInvalidArgumentError,\n  LDInvalidDataError,\n  LDFlagFetchError,\n  LDTimeoutError,\n  isHttpErrorRecoverable,\n};\n","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","'use strict';\n\nvar isArray = Array.isArray;\nvar keyList = Object.keys;\nvar hasProp = Object.prototype.hasOwnProperty;\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    var arrA = isArray(a)\n      , arrB = isArray(b)\n      , i\n      , length\n      , key;\n\n    if (arrA && arrB) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n    if (arrA != arrB) return false;\n\n    var dateA = a instanceof Date\n      , dateB = b instanceof Date;\n    if (dateA != dateB) return false;\n    if (dateA && dateB) return a.getTime() == b.getTime();\n\n    var regexpA = a instanceof RegExp\n      , regexpB = b instanceof RegExp;\n    if (regexpA != regexpB) return false;\n    if (regexpA && regexpB) return a.toString() == b.toString();\n\n    var keys = keyList(a);\n    length = keys.length;\n\n    if (length !== keyList(b).length)\n      return false;\n\n    for (i = length; i-- !== 0;)\n      if (!hasProp.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      key = keys[i];\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  return a!==a && b!==b;\n};\n","const base64 = require('base64-js');\nconst fastDeepEqual = require('fast-deep-equal');\n\nconst userAttrsToStringify = ['key', 'ip', 'country', 'email', 'firstName', 'lastName', 'avatar', 'name'];\n\nfunction appendUrlPath(baseUrl, path) {\n  // Ensure that URL concatenation is done correctly regardless of whether the\n  // base URL has a trailing slash or not.\n  const trimBaseUrl = baseUrl.endsWith('/') ? baseUrl.substring(0, baseUrl.length - 1) : baseUrl;\n  return trimBaseUrl + (path.startsWith('/') ? '' : '/') + path;\n}\n\n// See http://ecmanaut.blogspot.com/2006/07/encoding-decoding-utf8-in-javascript.html\nfunction btoa(s) {\n  const escaped = unescape(encodeURIComponent(s));\n  return base64.fromByteArray(stringToBytes(escaped));\n}\n\nfunction stringToBytes(s) {\n  const b = [];\n  for (let i = 0; i < s.length; i++) {\n    b.push(s.charCodeAt(i));\n  }\n  return b;\n}\n\nfunction base64URLEncode(s) {\n  return (\n    btoa(s)\n      // eslint-disable-next-line\n      .replace(/=/g, '')\n      .replace(/\\+/g, '-')\n      .replace(/\\//g, '_')\n  );\n}\n\nfunction clone(obj) {\n  return JSON.parse(JSON.stringify(obj));\n}\n\nfunction deepEquals(a, b) {\n  return fastDeepEqual(a, b);\n}\n\n// Events emitted in LDClient's initialize method will happen before the consumer\n// can register a listener, so defer them to next tick.\nfunction onNextTick(cb) {\n  setTimeout(cb, 0);\n}\n\n/**\n * Wrap a promise to invoke an optional callback upon resolution or rejection.\n *\n * This function assumes the callback follows the Node.js callback type: (err, value) => void\n *\n * If a callback is provided:\n *   - if the promise is resolved, invoke the callback with (null, value)\n *   - if the promise is rejected, invoke the callback with (error, null)\n *\n * @param {Promise<any>} promise\n * @param {Function} callback\n * @returns Promise<any> | undefined\n */\nfunction wrapPromiseCallback(promise, callback) {\n  const ret = promise.then(\n    value => {\n      if (callback) {\n        setTimeout(() => {\n          callback(null, value);\n        }, 0);\n      }\n      return value;\n    },\n    error => {\n      if (callback) {\n        setTimeout(() => {\n          callback(error, null);\n        }, 0);\n      } else {\n        return Promise.reject(error);\n      }\n    }\n  );\n\n  return !callback ? ret : undefined;\n}\n\n/**\n * Takes a map of flag keys to values, and returns the more verbose structure used by the\n * client stream.\n */\nfunction transformValuesToVersionedValues(flags) {\n  const ret = {};\n  for (const key in flags) {\n    if (objectHasOwnProperty(flags, key)) {\n      ret[key] = { value: flags[key], version: 0 };\n    }\n  }\n  return ret;\n}\n\n/**\n * Converts the internal flag state map to a simple map of flag keys to values.\n */\nfunction transformVersionedValuesToValues(flagsState) {\n  const ret = {};\n  for (const key in flagsState) {\n    if (objectHasOwnProperty(flagsState, key)) {\n      ret[key] = flagsState[key].value;\n    }\n  }\n  return ret;\n}\n\nfunction getLDUserAgentString(platform) {\n  const version = platform.version || '?';\n  return platform.userAgent + '/' + version;\n}\n\nfunction extend(...objects) {\n  return objects.reduce((acc, obj) => ({ ...acc, ...obj }), {});\n}\n\nfunction objectHasOwnProperty(object, name) {\n  return Object.prototype.hasOwnProperty.call(object, name);\n}\n\nfunction sanitizeContext(context) {\n  if (!context) {\n    return context;\n  }\n  let newContext;\n  // Only stringify user attributes for legacy users.\n  if (context.kind === null || context.kind === undefined) {\n    userAttrsToStringify.forEach(attr => {\n      const value = context[attr];\n      if (value !== undefined && typeof value !== 'string') {\n        newContext = newContext || { ...context };\n        newContext[attr] = String(value);\n      }\n    });\n  }\n\n  return newContext || context;\n}\n\nmodule.exports = {\n  appendUrlPath,\n  base64URLEncode,\n  btoa,\n  clone,\n  deepEquals,\n  extend,\n  getLDUserAgentString,\n  objectHasOwnProperty,\n  onNextTick,\n  sanitizeContext,\n  transformValuesToVersionedValues,\n  transformVersionedValuesToValues,\n  wrapPromiseCallback,\n};\n","// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nvar getRandomValues;\nvar rnds8 = new Uint8Array(16);\nexport default function rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation. Also,\n    // find the complete implementation of crypto (msCrypto) on IE11.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}","export default /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;","import REGEX from './regex.js';\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && REGEX.test(uuid);\n}\n\nexport default validate;","import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nvar byteToHex = [];\n\nfor (var i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).substr(1));\n}\n\nfunction stringify(arr) {\n  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;","import rng from './rng.js';\nimport stringify from './stringify.js'; // **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nvar _nodeId;\n\nvar _clockseq; // Previous uuid creation time\n\n\nvar _lastMSecs = 0;\nvar _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details\n\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || new Array(16);\n  options = options || {};\n  var node = options.node || _nodeId;\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n\n  if (node == null || clockseq == null) {\n    var seedBytes = options.random || (options.rng || rng)();\n\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];\n    }\n\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n\n\n  var msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)\n\n  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression\n\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n\n\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  } // Per 4.2.1.2 Throw error if too many uuids are requested\n\n\n  if (nsecs >= 10000) {\n    throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n\n  msecs += 12219292800000; // `time_low`\n\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff; // `time_mid`\n\n  var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff; // `time_high_and_version`\n\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n\n  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n\n  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`\n\n  b[i++] = clockseq & 0xff; // `node`\n\n  for (var n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf || stringify(b);\n}\n\nexport default v1;","import validate from './validate.js';\n\nfunction parse(uuid) {\n  if (!validate(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  var v;\n  var arr = new Uint8Array(16); // Parse ########-....-....-....-............\n\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = v >>> 16 & 0xff;\n  arr[2] = v >>> 8 & 0xff;\n  arr[3] = v & 0xff; // Parse ........-####-....-....-............\n\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff; // Parse ........-....-####-....-............\n\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff; // Parse ........-....-....-####-............\n\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff; // Parse ........-....-....-....-############\n  // (Use \"/\" to avoid 32-bit truncation when bit-shifting high-order bytes)\n\n  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;\n  arr[11] = v / 0x100000000 & 0xff;\n  arr[12] = v >>> 24 & 0xff;\n  arr[13] = v >>> 16 & 0xff;\n  arr[14] = v >>> 8 & 0xff;\n  arr[15] = v & 0xff;\n  return arr;\n}\n\nexport default parse;","import stringify from './stringify.js';\nimport parse from './parse.js';\n\nfunction stringToBytes(str) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n\n  var bytes = [];\n\n  for (var i = 0; i < str.length; ++i) {\n    bytes.push(str.charCodeAt(i));\n  }\n\n  return bytes;\n}\n\nexport var DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nexport var URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\nexport default function (name, version, hashfunc) {\n  function generateUUID(value, namespace, buf, offset) {\n    if (typeof value === 'string') {\n      value = stringToBytes(value);\n    }\n\n    if (typeof namespace === 'string') {\n      namespace = parse(namespace);\n    }\n\n    if (namespace.length !== 16) {\n      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    } // Compute hash of namespace and value, Per 4.3\n    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =\n    // hashfunc([...namespace, ... value])`\n\n\n    var bytes = new Uint8Array(16 + value.length);\n    bytes.set(namespace);\n    bytes.set(value, namespace.length);\n    bytes = hashfunc(bytes);\n    bytes[6] = bytes[6] & 0x0f | version;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n\n    if (buf) {\n      offset = offset || 0;\n\n      for (var i = 0; i < 16; ++i) {\n        buf[offset + i] = bytes[i];\n      }\n\n      return buf;\n    }\n\n    return stringify(bytes);\n  } // Function#name is not settable on some platforms (#270)\n\n\n  try {\n    generateUUID.name = name; // eslint-disable-next-line no-empty\n  } catch (err) {} // For CommonJS default export support\n\n\n  generateUUID.DNS = DNS;\n  generateUUID.URL = URL;\n  return generateUUID;\n}","/*\n * Browser-compatible JavaScript MD5\n *\n * Modification of JavaScript MD5\n * https://github.com/blueimp/JavaScript-MD5\n *\n * Copyright 2011, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n *\n * Based on\n * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message\n * Digest Algorithm, as defined in RFC 1321.\n * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for more info.\n */\nfunction md5(bytes) {\n  if (typeof bytes === 'string') {\n    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape\n\n    bytes = new Uint8Array(msg.length);\n\n    for (var i = 0; i < msg.length; ++i) {\n      bytes[i] = msg.charCodeAt(i);\n    }\n  }\n\n  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));\n}\n/*\n * Convert an array of little-endian words to an array of bytes\n */\n\n\nfunction md5ToHexEncodedArray(input) {\n  var output = [];\n  var length32 = input.length * 32;\n  var hexTab = '0123456789abcdef';\n\n  for (var i = 0; i < length32; i += 8) {\n    var x = input[i >> 5] >>> i % 32 & 0xff;\n    var hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);\n    output.push(hex);\n  }\n\n  return output;\n}\n/**\n * Calculate output length with padding and bit length\n */\n\n\nfunction getOutputLength(inputLength8) {\n  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;\n}\n/*\n * Calculate the MD5 of an array of little-endian words, and a bit length.\n */\n\n\nfunction wordsToMd5(x, len) {\n  /* append padding */\n  x[len >> 5] |= 0x80 << len % 32;\n  x[getOutputLength(len) - 1] = len;\n  var a = 1732584193;\n  var b = -271733879;\n  var c = -1732584194;\n  var d = 271733878;\n\n  for (var i = 0; i < x.length; i += 16) {\n    var olda = a;\n    var oldb = b;\n    var oldc = c;\n    var oldd = d;\n    a = md5ff(a, b, c, d, x[i], 7, -680876936);\n    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);\n    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);\n    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);\n    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);\n    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);\n    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);\n    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);\n    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);\n    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);\n    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);\n    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);\n    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);\n    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);\n    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);\n    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);\n    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);\n    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);\n    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);\n    b = md5gg(b, c, d, a, x[i], 20, -373897302);\n    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);\n    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);\n    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);\n    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);\n    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);\n    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);\n    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);\n    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);\n    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);\n    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);\n    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);\n    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);\n    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);\n    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);\n    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);\n    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);\n    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);\n    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);\n    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);\n    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);\n    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);\n    d = md5hh(d, a, b, c, x[i], 11, -358537222);\n    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);\n    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);\n    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);\n    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);\n    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);\n    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);\n    a = md5ii(a, b, c, d, x[i], 6, -198630844);\n    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);\n    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);\n    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);\n    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);\n    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);\n    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);\n    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);\n    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);\n    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);\n    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);\n    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);\n    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);\n    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);\n    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);\n    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);\n    a = safeAdd(a, olda);\n    b = safeAdd(b, oldb);\n    c = safeAdd(c, oldc);\n    d = safeAdd(d, oldd);\n  }\n\n  return [a, b, c, d];\n}\n/*\n * Convert an array bytes to an array of little-endian words\n * Characters >255 have their high-byte silently ignored.\n */\n\n\nfunction bytesToWords(input) {\n  if (input.length === 0) {\n    return [];\n  }\n\n  var length8 = input.length * 8;\n  var output = new Uint32Array(getOutputLength(length8));\n\n  for (var i = 0; i < length8; i += 8) {\n    output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;\n  }\n\n  return output;\n}\n/*\n * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n * to work around bugs in some JS interpreters.\n */\n\n\nfunction safeAdd(x, y) {\n  var lsw = (x & 0xffff) + (y & 0xffff);\n  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n  return msw << 16 | lsw & 0xffff;\n}\n/*\n * Bitwise rotate a 32-bit number to the left.\n */\n\n\nfunction bitRotateLeft(num, cnt) {\n  return num << cnt | num >>> 32 - cnt;\n}\n/*\n * These functions implement the four basic operations the algorithm uses.\n */\n\n\nfunction md5cmn(q, a, b, x, s, t) {\n  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);\n}\n\nfunction md5ff(a, b, c, d, x, s, t) {\n  return md5cmn(b & c | ~b & d, a, b, x, s, t);\n}\n\nfunction md5gg(a, b, c, d, x, s, t) {\n  return md5cmn(b & d | c & ~d, a, b, x, s, t);\n}\n\nfunction md5hh(a, b, c, d, x, s, t) {\n  return md5cmn(b ^ c ^ d, a, b, x, s, t);\n}\n\nfunction md5ii(a, b, c, d, x, s, t) {\n  return md5cmn(c ^ (b | ~d), a, b, x, s, t);\n}\n\nexport default md5;","import v35 from './v35.js';\nimport md5 from './md5.js';\nvar v3 = v35('v3', 0x30, md5);\nexport default v3;","// Adapted from Chris Veness' SHA1 code at\n// http://www.movable-type.co.uk/scripts/sha1.html\nfunction f(s, x, y, z) {\n  switch (s) {\n    case 0:\n      return x & y ^ ~x & z;\n\n    case 1:\n      return x ^ y ^ z;\n\n    case 2:\n      return x & y ^ x & z ^ y & z;\n\n    case 3:\n      return x ^ y ^ z;\n  }\n}\n\nfunction ROTL(x, n) {\n  return x << n | x >>> 32 - n;\n}\n\nfunction sha1(bytes) {\n  var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];\n  var H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];\n\n  if (typeof bytes === 'string') {\n    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape\n\n    bytes = [];\n\n    for (var i = 0; i < msg.length; ++i) {\n      bytes.push(msg.charCodeAt(i));\n    }\n  } else if (!Array.isArray(bytes)) {\n    // Convert Array-like to Array\n    bytes = Array.prototype.slice.call(bytes);\n  }\n\n  bytes.push(0x80);\n  var l = bytes.length / 4 + 2;\n  var N = Math.ceil(l / 16);\n  var M = new Array(N);\n\n  for (var _i = 0; _i < N; ++_i) {\n    var arr = new Uint32Array(16);\n\n    for (var j = 0; j < 16; ++j) {\n      arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];\n    }\n\n    M[_i] = arr;\n  }\n\n  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);\n  M[N - 1][14] = Math.floor(M[N - 1][14]);\n  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;\n\n  for (var _i2 = 0; _i2 < N; ++_i2) {\n    var W = new Uint32Array(80);\n\n    for (var t = 0; t < 16; ++t) {\n      W[t] = M[_i2][t];\n    }\n\n    for (var _t = 16; _t < 80; ++_t) {\n      W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);\n    }\n\n    var a = H[0];\n    var b = H[1];\n    var c = H[2];\n    var d = H[3];\n    var e = H[4];\n\n    for (var _t2 = 0; _t2 < 80; ++_t2) {\n      var s = Math.floor(_t2 / 20);\n      var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[_t2] >>> 0;\n      e = d;\n      d = c;\n      c = ROTL(b, 30) >>> 0;\n      b = a;\n      a = T;\n    }\n\n    H[0] = H[0] + a >>> 0;\n    H[1] = H[1] + b >>> 0;\n    H[2] = H[2] + c >>> 0;\n    H[3] = H[3] + d >>> 0;\n    H[4] = H[4] + e >>> 0;\n  }\n\n  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];\n}\n\nexport default sha1;","import v35 from './v35.js';\nimport sha1 from './sha1.js';\nvar v5 = v35('v5', 0x50, sha1);\nexport default v5;","import rng from './rng.js';\nimport stringify from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  options = options || {};\n  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (var i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return stringify(rnds);\n}\n\nexport default v4;","export default '00000000-0000-0000-0000-000000000000';","import validate from './validate.js';\n\nfunction version(uuid) {\n  if (!validate(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  return parseInt(uuid.substr(14, 1), 16);\n}\n\nexport default version;","const logLevels = ['debug', 'info', 'warn', 'error', 'none'];\n\n/**\n * A simple logger that writes to stderr.\n */\nfunction commonBasicLogger(options, formatFn) {\n  if (options && options.destination && typeof options.destination !== 'function') {\n    throw new Error('destination for basicLogger was set to a non-function');\n  }\n\n  function toConsole(methodName) {\n    // The global console variable is not guaranteed to be defined at all times in all browsers:\n    // https://www.beyondjava.net/console-log-surprises-with-internet-explorer-11-and-edge\n    return function(line) {\n      if (console && console[methodName]) {\n        console[methodName].call(console, line);\n      }\n    };\n  }\n  const destinations =\n    options && options.destination\n      ? [options.destination, options.destination, options.destination, options.destination]\n      : [toConsole('log'), toConsole('info'), toConsole('warn'), toConsole('error')];\n  const prependLevelToMessage = !!(options && options.destination); // if we're writing to console.warn, etc. we don't need the prefix\n  const prefix =\n    !options || options.prefix === undefined || options.prefix === null ? '[LaunchDarkly] ' : options.prefix;\n\n  let minLevel = 1; // default is 'info'\n  if (options && options.level) {\n    for (let i = 0; i < logLevels.length; i++) {\n      if (logLevels[i] === options.level) {\n        minLevel = i;\n      }\n    }\n  }\n\n  function write(levelIndex, levelName, args) {\n    if (args.length < 1) {\n      return;\n    }\n    let line;\n    const fullPrefix = prependLevelToMessage ? levelName + ': ' + prefix : prefix;\n    if (args.length === 1 || !formatFn) {\n      line = fullPrefix + args[0];\n    } else {\n      const tempArgs = [...args];\n      tempArgs[0] = fullPrefix + tempArgs[0];\n      line = formatFn(...tempArgs);\n    }\n    try {\n      destinations[levelIndex](line);\n    } catch (err) {\n      console &&\n        console.log &&\n        console.log(\"[LaunchDarkly] Configured logger's \" + levelName + ' method threw an exception: ' + err);\n    }\n  }\n\n  const logger = {};\n  for (let i = 0; i < logLevels.length; i++) {\n    const levelName = logLevels[i];\n    if (levelName !== 'none') {\n      if (i < minLevel) {\n        logger[levelName] = () => {};\n      } else {\n        const levelIndex = i;\n        logger[levelName] = function() {\n          // can't use arrow function with \"arguments\"\n          write(levelIndex, levelName, arguments);\n        };\n      }\n    }\n  }\n\n  return logger;\n}\n\nfunction validateLogger(logger) {\n  logLevels.forEach(level => {\n    if (level !== 'none' && (!logger[level] || typeof logger[level] !== 'function')) {\n      throw new Error('Provided logger instance must support logger.' + level + '(...) method');\n      // Note that the SDK normally does not throw exceptions to the application, but that rule\n      // does not apply to LDClient.init() which will throw an exception if the parameters are so\n      // invalid that we cannot proceed with creating the client. An invalid logger meets those\n      // criteria since the SDK calls the logger during nearly all of its operations.\n    }\n  });\n}\n\nmodule.exports = {\n  commonBasicLogger,\n  validateLogger,\n};\n","const errors = require('./errors');\n\nfunction errorString(err) {\n  if (err && err.message) {\n    return err.message;\n  }\n  if (typeof err === 'string' || err instanceof String) {\n    return err;\n  }\n  return JSON.stringify(err);\n}\n\nconst clientInitialized = function() {\n  return 'LaunchDarkly client initialized';\n};\n\nconst docLink =\n  ' Please see https://docs.launchdarkly.com/sdk/client-side/javascript#initialize-the-client for instructions on SDK initialization.';\n\nconst clientNotReady = function() {\n  return 'LaunchDarkly client is not ready';\n};\n\nconst eventCapacityExceeded = function() {\n  return 'Exceeded event queue capacity. Increase capacity to avoid dropping events.';\n};\n\nconst eventWithoutContext = function() {\n  return 'Be sure to call `identify` in the LaunchDarkly client: https://docs.launchdarkly.com/sdk/features/identify#javascript';\n};\n\nconst invalidContentType = function(contentType) {\n  return 'Expected application/json content type but got \"' + contentType + '\"';\n};\n\nconst invalidKey = function() {\n  return 'Event key must be a string';\n};\n\nconst localStorageUnavailable = function(err) {\n  return 'local storage is unavailable: ' + errorString(err);\n};\n\nconst networkError = e => 'network error' + (e ? ' (' + e + ')' : '');\n\n// We should remove unknownCustomEventKey in the future - see comments in track() in index.js\nconst unknownCustomEventKey = function(key) {\n  return 'Custom event \"' + key + '\" does not exist';\n};\n\nconst environmentNotFound = function() {\n  return 'Environment not found. Double check that you specified a valid environment/client-side ID.' + docLink;\n};\n\nconst environmentNotSpecified = function() {\n  return 'No environment/client-side ID was specified.' + docLink;\n};\n\nconst errorFetchingFlags = function(err) {\n  return 'Error fetching flag settings: ' + errorString(err);\n};\n\nconst contextNotSpecified = function() {\n  return 'No context specified.' + docLink;\n};\n\nconst invalidContext = function() {\n  return 'Invalid context specified.' + docLink;\n};\n\nconst invalidData = function() {\n  return 'Invalid data received from LaunchDarkly; connection may have been interrupted';\n};\n\nconst bootstrapOldFormat = function() {\n  return (\n    'LaunchDarkly client was initialized with bootstrap data that did not include flag metadata. ' +\n    'Events may not be sent correctly.' +\n    docLink\n  );\n};\n\nconst bootstrapInvalid = function() {\n  return 'LaunchDarkly bootstrap data is not available because the back end could not read the flags.';\n};\n\nconst deprecated = function(oldName, newName) {\n  if (newName) {\n    return '\"' + oldName + '\" is deprecated, please use \"' + newName + '\"';\n  }\n  return '\"' + oldName + '\" is deprecated';\n};\n\nconst httpErrorMessage = function(status, context, retryMessage) {\n  return (\n    'Received error ' +\n    status +\n    (status === 401 ? ' (invalid SDK key)' : '') +\n    ' for ' +\n    context +\n    ' - ' +\n    (errors.isHttpErrorRecoverable(status) ? retryMessage : 'giving up permanently')\n  );\n};\n\nconst httpUnavailable = function() {\n  return 'Cannot make HTTP requests in this environment.' + docLink;\n};\n\nconst identifyDisabled = function() {\n  return 'identify() has no effect here; it must be called on the main client instance';\n};\n\nconst streamClosing = function() {\n  return 'Closing stream connection';\n};\n\nconst streamConnecting = function(url) {\n  return 'Opening stream connection to ' + url;\n};\n\nconst streamError = function(err, streamReconnectDelay) {\n  return (\n    'Error on stream connection: ' +\n    errorString(err) +\n    ', will continue retrying after ' +\n    streamReconnectDelay +\n    ' milliseconds.'\n  );\n};\n\nconst unknownOption = name => 'Ignoring unknown config option \"' + name + '\"';\n\nconst unrecoverableStreamError = err => `Error on stream connection ${errorString(err)}, giving up permanently`;\n\nconst wrongOptionType = (name, expectedType, actualType) =>\n  'Config option \"' + name + '\" should be of type ' + expectedType + ', got ' + actualType + ', using default value';\n\nconst wrongOptionTypeBoolean = (name, actualType) =>\n  'Config option \"' + name + '\" should be a boolean, got ' + actualType + ', converting to boolean';\n\nconst optionBelowMinimum = (name, value, minimum) =>\n  'Config option \"' + name + '\" was set to ' + value + ', changing to minimum value of ' + minimum;\n\nconst debugPolling = function(url) {\n  return 'polling for feature flags at ' + url;\n};\n\nconst debugStreamPing = function() {\n  return 'received ping message from stream';\n};\n\nconst debugStreamPut = function() {\n  return 'received streaming update for all flags';\n};\n\nconst debugStreamPatch = function(key) {\n  return 'received streaming update for flag \"' + key + '\"';\n};\n\nconst debugStreamPatchIgnored = function(key) {\n  return 'received streaming update for flag \"' + key + '\" but ignored due to version check';\n};\n\nconst debugStreamDelete = function(key) {\n  return 'received streaming deletion for flag \"' + key + '\"';\n};\n\nconst debugStreamDeleteIgnored = function(key) {\n  return 'received streaming deletion for flag \"' + key + '\" but ignored due to version check';\n};\n\nconst debugEnqueueingEvent = function(kind) {\n  return 'enqueueing \"' + kind + '\" event';\n};\n\nconst debugPostingEvents = function(count) {\n  return 'sending ' + count + ' events';\n};\n\nconst debugPostingDiagnosticEvent = function(event) {\n  return 'sending diagnostic event (' + event.kind + ')';\n};\n\nconst invalidInspector = (type, name) => `an inspector: \"${name}\" of an invalid type (${type}) was configured`;\n\nconst inspectorMethodError = (type, name) => `an inspector: \"${name}\" of type: \"${type}\" generated an exception`;\n\nconst invalidTagValue = name => `Config option \"${name}\" must only contain letters, numbers, ., _ or -.`;\n\nconst tagValueTooLong = name => `Value of \"${name}\" was longer than 64 characters and was discarded.`;\n\nconst invalidMetricValue = badType =>\n  `The track function was called with a non-numeric \"metricValue\" (${badType}), only numeric metric values are supported.`;\n\nmodule.exports = {\n  bootstrapInvalid,\n  bootstrapOldFormat,\n  clientInitialized,\n  clientNotReady,\n  debugEnqueueingEvent,\n  debugPostingDiagnosticEvent,\n  debugPostingEvents,\n  debugStreamDelete,\n  debugStreamDeleteIgnored,\n  debugStreamPatch,\n  debugStreamPatchIgnored,\n  debugStreamPing,\n  debugPolling,\n  debugStreamPut,\n  deprecated,\n  environmentNotFound,\n  environmentNotSpecified,\n  errorFetchingFlags,\n  eventCapacityExceeded,\n  eventWithoutContext,\n  httpErrorMessage,\n  httpUnavailable,\n  identifyDisabled,\n  inspectorMethodError,\n  invalidContentType,\n  invalidData,\n  invalidInspector,\n  invalidKey,\n  invalidMetricValue,\n  invalidContext,\n  invalidTagValue,\n  localStorageUnavailable,\n  networkError,\n  optionBelowMinimum,\n  streamClosing,\n  streamConnecting,\n  streamError,\n  tagValueTooLong,\n  unknownCustomEventKey,\n  unknownOption,\n  contextNotSpecified,\n  unrecoverableStreamError,\n  wrongOptionType,\n  wrongOptionTypeBoolean,\n};\n","const errors = require('./errors');\nconst { validateLogger } = require('./loggers');\nconst messages = require('./messages');\nconst utils = require('./utils');\n\n// baseOptionDefs should contain an entry for each supported configuration option in the common package.\n// Each entry can have three properties:\n// - \"default\": the default value if any\n// - \"type\": a type constraint used if the type can't be inferred from the default value). The allowable\n//   values are \"boolean\", \"string\", \"number\", \"array\", \"object\", \"function\", or several of these OR'd\n//   together with \"|\" (\"function|object\").\n// - \"minimum\": minimum value if any for numeric properties\n//\n// The extraOptionDefs parameter to validate() uses the same format.\nconst baseOptionDefs = {\n  baseUrl: { default: 'https://app.launchdarkly.com' },\n  streamUrl: { default: 'https://clientstream.launchdarkly.com' },\n  eventsUrl: { default: 'https://events.launchdarkly.com' },\n  sendEvents: { default: true },\n  streaming: { type: 'boolean' }, // default for this is undefined, which is different from false\n  sendLDHeaders: { default: true },\n  requestHeaderTransform: { type: 'function' },\n  sendEventsOnlyForVariation: { default: false },\n  useReport: { default: false },\n  evaluationReasons: { default: false },\n  eventCapacity: { default: 100, minimum: 1 },\n  flushInterval: { default: 2000, minimum: 2000 },\n  samplingInterval: { default: 0, minimum: 0 },\n  streamReconnectDelay: { default: 1000, minimum: 0 },\n  allAttributesPrivate: { default: false },\n  privateAttributes: { default: [] },\n  bootstrap: { type: 'string|object' },\n  diagnosticRecordingInterval: { default: 900000, minimum: 2000 },\n  diagnosticOptOut: { default: false },\n  wrapperName: { type: 'string' },\n  wrapperVersion: { type: 'string' },\n  stateProvider: { type: 'object' }, // not a public option, used internally\n  application: { validator: applicationConfigValidator },\n  inspectors: { default: [] },\n};\n\n/**\n * Expression to validate characters that are allowed in tag keys and values.\n */\nconst allowedTagCharacters = /^(\\w|\\.|-)+$/;\n\nfunction canonicalizeUrl(url) {\n  return url && url.replace(/\\/+$/, '');\n}\n\n/**\n * Verify that a value meets the requirements for a tag value.\n * @param {string} tagValue\n * @param {Object} logger\n */\nfunction validateTagValue(name, tagValue, logger) {\n  if (typeof tagValue !== 'string' || !tagValue.match(allowedTagCharacters)) {\n    logger.warn(messages.invalidTagValue(name));\n    return undefined;\n  }\n  if (tagValue.length > 64) {\n    logger.warn(messages.tagValueTooLong(name));\n    return undefined;\n  }\n  return tagValue;\n}\n\nfunction applicationConfigValidator(name, value, logger) {\n  const validated = {};\n  if (value.id) {\n    validated.id = validateTagValue(`${name}.id`, value.id, logger);\n  }\n  if (value.version) {\n    validated.version = validateTagValue(`${name}.version`, value.version, logger);\n  }\n  return validated;\n}\n\nfunction validate(options, emitter, extraOptionDefs, logger) {\n  const optionDefs = utils.extend({ logger: { default: logger } }, baseOptionDefs, extraOptionDefs);\n\n  const deprecatedOptions = {\n    // As of the latest major version, there are no deprecated options. Next time we deprecate\n    // something, add an item here where the property name is the deprecated name, and the\n    // property value is the preferred name if any, or null/undefined if there is no replacement.\n  };\n\n  function checkDeprecatedOptions(config) {\n    const opts = config;\n    Object.keys(deprecatedOptions).forEach(oldName => {\n      if (opts[oldName] !== undefined) {\n        const newName = deprecatedOptions[oldName];\n        logger && logger.warn(messages.deprecated(oldName, newName));\n        if (newName) {\n          if (opts[newName] === undefined) {\n            opts[newName] = opts[oldName];\n          }\n          delete opts[oldName];\n        }\n      }\n    });\n  }\n\n  function applyDefaults(config) {\n    // This works differently from utils.extend() in that it *will not* override a default value\n    // if the provided value is explicitly set to null. This provides backward compatibility\n    // since in the past we only used the provided values if they were truthy.\n    const ret = utils.extend({}, config);\n    Object.keys(optionDefs).forEach(name => {\n      if (ret[name] === undefined || ret[name] === null) {\n        ret[name] = optionDefs[name] && optionDefs[name].default;\n      }\n    });\n    return ret;\n  }\n\n  function validateTypesAndNames(config) {\n    const ret = utils.extend({}, config);\n    const typeDescForValue = value => {\n      if (value === null) {\n        return 'any';\n      }\n      if (value === undefined) {\n        return undefined;\n      }\n      if (Array.isArray(value)) {\n        return 'array';\n      }\n      const t = typeof value;\n      if (t === 'boolean' || t === 'string' || t === 'number' || t === 'function') {\n        return t;\n      }\n      return 'object';\n    };\n    Object.keys(config).forEach(name => {\n      const value = config[name];\n      if (value !== null && value !== undefined) {\n        const optionDef = optionDefs[name];\n        if (optionDef === undefined) {\n          reportArgumentError(messages.unknownOption(name));\n        } else {\n          const expectedType = optionDef.type || typeDescForValue(optionDef.default);\n          const validator = optionDef.validator;\n          if (validator) {\n            const validated = validator(name, config[name], logger);\n            if (validated !== undefined) {\n              ret[name] = validated;\n            } else {\n              delete ret[name];\n            }\n          } else if (expectedType !== 'any') {\n            const allowedTypes = expectedType.split('|');\n            const actualType = typeDescForValue(value);\n            if (allowedTypes.indexOf(actualType) < 0) {\n              if (expectedType === 'boolean') {\n                ret[name] = !!value;\n                reportArgumentError(messages.wrongOptionTypeBoolean(name, actualType));\n              } else {\n                reportArgumentError(messages.wrongOptionType(name, expectedType, actualType));\n                ret[name] = optionDef.default;\n              }\n            } else {\n              if (actualType === 'number' && optionDef.minimum !== undefined && value < optionDef.minimum) {\n                reportArgumentError(messages.optionBelowMinimum(name, value, optionDef.minimum));\n                ret[name] = optionDef.minimum;\n              }\n            }\n          }\n        }\n      }\n    });\n\n    ret.baseUrl = canonicalizeUrl(ret.baseUrl);\n    ret.streamUrl = canonicalizeUrl(ret.streamUrl);\n    ret.eventsUrl = canonicalizeUrl(ret.eventsUrl);\n\n    return ret;\n  }\n\n  function reportArgumentError(message) {\n    utils.onNextTick(() => {\n      emitter && emitter.maybeReportError(new errors.LDInvalidArgumentError(message));\n    });\n  }\n\n  let config = utils.extend({}, options || {});\n\n  checkDeprecatedOptions(config);\n\n  config = applyDefaults(config);\n  config = validateTypesAndNames(config);\n  validateLogger(config.logger);\n\n  return config;\n}\n\n/**\n * Get tags for the specified configuration.\n *\n * If any additional tags are added to the configuration, then the tags from\n * this method should be extended with those.\n * @param {Object} config The already valiated configuration.\n * @returns {Object} The tag configuration.\n */\nfunction getTags(config) {\n  const tags = {};\n  if (config) {\n    if (config.application && config.application.id !== undefined && config.application.id !== null) {\n      tags['application-id'] = [config.application.id];\n    }\n    if (config.application && config.application.version !== undefined && config.application.id !== null) {\n      tags['application-version'] = [config.application.version];\n    }\n  }\n\n  return tags;\n}\n\nmodule.exports = {\n  baseOptionDefs,\n  validate,\n  getTags,\n};\n","const { getLDUserAgentString } = require('./utils');\nconst configuration = require('./configuration');\n\nfunction getLDHeaders(platform, options) {\n  if (options && !options.sendLDHeaders) {\n    return {};\n  }\n  const h = {};\n  h[platform.userAgentHeaderName || 'User-Agent'] = getLDUserAgentString(platform);\n  if (options && options.wrapperName) {\n    h['X-LaunchDarkly-Wrapper'] = options.wrapperVersion\n      ? options.wrapperName + '/' + options.wrapperVersion\n      : options.wrapperName;\n  }\n  const tags = configuration.getTags(options);\n  const tagKeys = Object.keys(tags);\n  if (tagKeys.length) {\n    h['x-launchdarkly-tags'] = tagKeys\n      .sort()\n      .map(key =>\n        Array.isArray(tags[key]) ? tags[key].sort().map(value => `${key}/${value}`) : [`${key}/${tags[key]}`]\n      )\n      .reduce((flattened, item) => flattened.concat(item), [])\n      .join(' ');\n  }\n  return h;\n}\n\nfunction transformHeaders(headers, options) {\n  if (!options || !options.requestHeaderTransform) {\n    return headers;\n  }\n  return options.requestHeaderTransform({ ...headers });\n}\n\nmodule.exports = {\n  getLDHeaders,\n  transformHeaders,\n};\n","const errors = require('./errors');\nconst utils = require('./utils');\nconst { v1: uuidv1 } = require('uuid');\nconst { getLDHeaders, transformHeaders } = require('./headers');\n\nfunction EventSender(platform, environmentId, options) {\n  const baseHeaders = utils.extend({ 'Content-Type': 'application/json' }, getLDHeaders(platform, options));\n  const sender = {};\n\n  function getResponseInfo(result) {\n    const ret = { status: result.status };\n    const dateStr = result.header('date');\n    if (dateStr) {\n      const time = Date.parse(dateStr);\n      if (time) {\n        ret.serverTime = time;\n      }\n    }\n    return ret;\n  }\n\n  sender.sendEvents = (events, url, isDiagnostic) => {\n    if (!platform.httpRequest) {\n      return Promise.resolve();\n    }\n\n    const jsonBody = JSON.stringify(events);\n    const payloadId = isDiagnostic ? null : uuidv1();\n\n    function doPostRequest(canRetry) {\n      const headers = isDiagnostic\n        ? baseHeaders\n        : utils.extend({}, baseHeaders, {\n            'X-LaunchDarkly-Event-Schema': '4',\n            'X-LaunchDarkly-Payload-ID': payloadId,\n          });\n      return platform\n        .httpRequest('POST', url, transformHeaders(headers, options), jsonBody)\n        .promise.then(result => {\n          if (!result) {\n            // This was a response from a fire-and-forget request, so we won't have a status.\n            return;\n          }\n          if (result.status >= 400 && errors.isHttpErrorRecoverable(result.status) && canRetry) {\n            return doPostRequest(false);\n          } else {\n            return getResponseInfo(result);\n          }\n        })\n        .catch(() => {\n          if (canRetry) {\n            return doPostRequest(false);\n          }\n          return Promise.reject();\n        });\n    }\n\n    return doPostRequest(true).catch(() => {});\n  };\n\n  return sender;\n}\n\nmodule.exports = EventSender;\n","/**\n * Validate a context kind.\n * @param {string} kind\n * @returns true if the kind is valid.\n */\nconst { commonBasicLogger } = require('./loggers');\n\nfunction validKind(kind) {\n  return typeof kind === 'string' && kind !== 'kind' && kind.match(/^(\\w|\\.|-)+$/);\n}\n\n/**\n * Perform a check of basic context requirements.\n * @param {Object} context\n * @param {boolean} allowLegacyKey If true, then a legacy user can have an\n * empty or non-string key. A legacy user is a context without a kind.\n * @returns true if the context meets basic requirements.\n */\nfunction checkContext(context, allowLegacyKey) {\n  if (context) {\n    if (allowLegacyKey && (context.kind === undefined || context.kind === null)) {\n      return context.key !== undefined && context.key !== null;\n    }\n    const key = context.key;\n    const kind = context.kind === undefined ? 'user' : context.kind;\n    const kindValid = validKind(kind);\n    const keyValid = kind === 'multi' || (key !== undefined && key !== null && key !== '');\n    if (kind === 'multi') {\n      const kinds = Object.keys(context).filter(key => key !== 'kind');\n      return (\n        keyValid &&\n        kinds.every(key => validKind(key)) &&\n        kinds.every(key => {\n          const contextKey = context[key].key;\n          return contextKey !== undefined && contextKey !== null && contextKey !== '';\n        })\n      );\n    }\n    return keyValid && kindValid;\n  }\n  return false;\n}\n\n/**\n * For a given context get a list of context kinds.\n * @param {Object} context\n * @returns A list of kinds in the context.\n */\nfunction getContextKinds(context) {\n  if (context) {\n    if (context.kind === null || context.kind === undefined) {\n      return ['user'];\n    }\n    if (context.kind !== 'multi') {\n      return [context.kind];\n    }\n    return Object.keys(context).filter(kind => kind !== 'kind');\n  }\n  return [];\n}\n\n/**\n * The partial URL encoding is needed because : is a valid character in context keys.\n *\n * Partial encoding is the replacement of all colon (:) characters with the URL\n * encoded equivalent (%3A) and all percent (%) characters with the URL encoded\n * equivalent (%25).\n * @param {string} key The key to encode.\n * @returns {string} Partially URL encoded key.\n */\nfunction encodeKey(key) {\n  if (key.includes('%') || key.includes(':')) {\n    return key.replace(/%/g, '%25').replace(/:/g, '%3A');\n  }\n  return key;\n}\n\nfunction getCanonicalKey(context) {\n  if (context) {\n    if ((context.kind === undefined || context.kind === null || context.kind === 'user') && context.key) {\n      return context.key;\n    } else if (context.kind !== 'multi' && context.key) {\n      return `${context.kind}:${encodeKey(context.key)}`;\n    } else if (context.kind === 'multi') {\n      return Object.keys(context)\n        .sort()\n        .filter(key => key !== 'kind')\n        .map(key => `${key}:${encodeKey(context[key].key)}`)\n        .join(':');\n    }\n  }\n}\n\nfunction getContextKeys(context, logger = commonBasicLogger()) {\n  if (!context) {\n    return undefined;\n  }\n\n  const keys = {};\n  const { kind, key } = context;\n\n  switch (kind) {\n    case undefined:\n      keys.user = `${key}`;\n      break;\n    case 'multi':\n      Object.entries(context)\n        .filter(([key]) => key !== 'kind')\n        .forEach(([key, value]) => {\n          if (value && value.key) {\n            keys[key] = value.key;\n          }\n        });\n      break;\n    case null:\n      logger.warn(`null is not a valid context kind: ${context}`);\n      break;\n    case '':\n      logger.warn(`'' is not a valid context kind: ${context}`);\n      break;\n    default:\n      keys[kind] = `${key}`;\n      break;\n  }\n\n  return keys;\n}\n\nmodule.exports = {\n  checkContext,\n  getContextKeys,\n  getContextKinds,\n  getCanonicalKey,\n};\n","const { getContextKinds } = require('./context');\n\nfunction getKinds(event) {\n  if (event.context) {\n    return getContextKinds(event.context);\n  }\n  if (event.contextKeys) {\n    return Object.keys(event.contextKeys);\n  }\n  return [];\n}\n\nfunction EventSummarizer() {\n  const es = {};\n\n  let startDate = 0,\n    endDate = 0,\n    counters = {},\n    contextKinds = {};\n\n  es.summarizeEvent = event => {\n    if (event.kind === 'feature') {\n      const counterKey =\n        event.key +\n        ':' +\n        (event.variation !== null && event.variation !== undefined ? event.variation : '') +\n        ':' +\n        (event.version !== null && event.version !== undefined ? event.version : '');\n      const counterVal = counters[counterKey];\n      let kinds = contextKinds[event.key];\n      if (!kinds) {\n        kinds = new Set();\n        contextKinds[event.key] = kinds;\n      }\n      getKinds(event).forEach(kind => kinds.add(kind));\n\n      if (counterVal) {\n        counterVal.count = counterVal.count + 1;\n      } else {\n        counters[counterKey] = {\n          count: 1,\n          key: event.key,\n          version: event.version,\n          variation: event.variation,\n          value: event.value,\n          default: event.default,\n        };\n      }\n      if (startDate === 0 || event.creationDate < startDate) {\n        startDate = event.creationDate;\n      }\n      if (event.creationDate > endDate) {\n        endDate = event.creationDate;\n      }\n    }\n  };\n\n  es.getSummary = () => {\n    const flagsOut = {};\n    let empty = true;\n    for (const c of Object.values(counters)) {\n      let flag = flagsOut[c.key];\n      if (!flag) {\n        flag = {\n          default: c.default,\n          counters: [],\n          contextKinds: [...contextKinds[c.key]],\n        };\n        flagsOut[c.key] = flag;\n      }\n      const counterOut = {\n        value: c.value,\n        count: c.count,\n      };\n      if (c.variation !== undefined && c.variation !== null) {\n        counterOut.variation = c.variation;\n      }\n      if (c.version !== undefined && c.version !== null) {\n        counterOut.version = c.version;\n      } else {\n        counterOut.unknown = true;\n      }\n      flag.counters.push(counterOut);\n      empty = false;\n    }\n    return empty\n      ? null\n      : {\n          startDate,\n          endDate,\n          features: flagsOut,\n        };\n  };\n\n  es.clearSummary = () => {\n    startDate = 0;\n    endDate = 0;\n    counters = {};\n    contextKinds = {};\n  };\n\n  return es;\n}\n\nmodule.exports = EventSummarizer;\n","/**\n * Take a key string and escape the characters to allow it to be used as a reference.\n * @param {string} key\n * @returns {string} The processed key.\n */\nfunction processEscapeCharacters(key) {\n  return key.replace(/~/g, '~0').replace(/\\//g, '~1');\n}\n\n/**\n * @param {string} reference The reference to get the components of.\n * @returns {string[]} The components of the reference. Escape characters will be converted to their representative values.\n */\nfunction getComponents(reference) {\n  const referenceWithoutPrefix = reference.startsWith('/') ? reference.substring(1) : reference;\n  return referenceWithoutPrefix\n    .split('/')\n    .map(component => (component.indexOf('~') >= 0 ? component.replace(/~1/g, '/').replace(/~0/g, '~') : component));\n}\n\n/**\n * @param {string} reference The reference to check if it is a literal.\n * @returns true if the reference is a literal.\n */\nfunction isLiteral(reference) {\n  return !reference.startsWith('/');\n}\n\n/**\n * Compare two references and determine if they are equivalent.\n * @param {string} a\n * @param {string} b\n */\nfunction compare(a, b) {\n  const aIsLiteral = isLiteral(a);\n  const bIsLiteral = isLiteral(b);\n  if (aIsLiteral && bIsLiteral) {\n    return a === b;\n  }\n  if (aIsLiteral) {\n    const bComponents = getComponents(b);\n    if (bComponents.length !== 1) {\n      return false;\n    }\n    return a === bComponents[0];\n  }\n  if (bIsLiteral) {\n    const aComponents = getComponents(a);\n    if (aComponents.length !== 1) {\n      return false;\n    }\n    return b === aComponents[0];\n  }\n  return a === b;\n}\n\n/**\n * @param {string} a\n * @param {string} b\n * @returns The two strings joined by '/'.\n */\nfunction join(a, b) {\n  return `${a}/${b}`;\n}\n\n/**\n * There are cases where a field could have been named with a preceeding '/'.\n * If that attribute was private, then the literal would appear to be a reference.\n * This method can be used to convert a literal to a reference in such situations.\n * @param {string} literal The literal to convert to a reference.\n * @returns A literal which has been converted to a reference.\n */\nfunction literalToReference(literal) {\n  return `/${processEscapeCharacters(literal)}`;\n}\n\n/**\n * Clone an object excluding the values referenced by a list of references.\n * @param {Object} target The object to clone.\n * @param {string[]} references A list of references from the cloned object.\n * @returns {{cloned: Object, excluded: string[]}} The cloned object and a list of excluded values.\n */\nfunction cloneExcluding(target, references) {\n  const stack = [];\n  const cloned = {};\n  const excluded = [];\n\n  stack.push(\n    ...Object.keys(target).map(key => ({\n      key,\n      ptr: literalToReference(key),\n      source: target,\n      parent: cloned,\n      visited: [target],\n    }))\n  );\n\n  while (stack.length) {\n    const item = stack.pop();\n    if (!references.some(ptr => compare(ptr, item.ptr))) {\n      const value = item.source[item.key];\n\n      // Handle null because it overlaps with object, which we will want to handle later.\n      if (value === null) {\n        item.parent[item.key] = value;\n      } else if (Array.isArray(value)) {\n        item.parent[item.key] = [...value];\n      } else if (typeof value === 'object') {\n        //Arrays and null must already be handled.\n\n        //Prevent cycles by not visiting the same object\n        //with in the same branch. Parallel branches\n        //may contain the same object.\n        if (item.visited.includes(value)) {\n          continue;\n        }\n\n        item.parent[item.key] = {};\n\n        stack.push(\n          ...Object.keys(value).map(key => ({\n            key,\n            ptr: join(item.ptr, processEscapeCharacters(key)),\n            source: value,\n            parent: item.parent[item.key],\n            visited: [...item.visited, value],\n          }))\n        );\n      } else {\n        item.parent[item.key] = value;\n      }\n    } else {\n      excluded.push(item.ptr);\n    }\n  }\n  return { cloned, excluded: excluded.sort() };\n}\n\nmodule.exports = {\n  cloneExcluding,\n  compare,\n  literalToReference,\n};\n","const AttributeReference = require('./attributeReference');\n\nfunction ContextFilter(config) {\n  const filter = {};\n\n  const allAttributesPrivate = config.allAttributesPrivate;\n  const privateAttributes = config.privateAttributes || [];\n\n  // These attributes cannot be removed via a private attribute.\n  const protectedAttributes = ['key', 'kind', '_meta', 'anonymous'];\n\n  const legacyTopLevelCopyAttributes = ['name', 'ip', 'firstName', 'lastName', 'email', 'avatar', 'country'];\n\n  /**\n   * For the given context and configuration get a list of attributes to filter.\n   * @param {Object} context\n   * @returns {string[]} A list of the attributes to filter.\n   */\n  const getAttributesToFilter = (context, redactAnonymous) =>\n    (allAttributesPrivate || (redactAnonymous && context.anonymous)\n      ? Object.keys(context)\n      : [...privateAttributes, ...((context._meta && context._meta.privateAttributes) || [])]\n    ).filter(attr => !protectedAttributes.some(protectedAttr => AttributeReference.compare(attr, protectedAttr)));\n\n  /**\n   * @param {Object} context\n   * @param {boolean} redactAnonymous\n   * @returns {Object} A copy of the context with private attributes removed,\n   * and the redactedAttributes meta populated.\n   */\n  const filterSingleKind = (context, redactAnonymous) => {\n    if (typeof context !== 'object' || context === null || Array.isArray(context)) {\n      return undefined;\n    }\n\n    const { cloned, excluded } = AttributeReference.cloneExcluding(\n      context,\n      getAttributesToFilter(context, redactAnonymous)\n    );\n    cloned.key = String(cloned.key);\n    if (excluded.length) {\n      if (!cloned._meta) {\n        cloned._meta = {};\n      }\n      cloned._meta.redactedAttributes = excluded;\n    }\n    if (cloned._meta) {\n      delete cloned._meta['privateAttributes'];\n      if (Object.keys(cloned._meta).length === 0) {\n        delete cloned._meta;\n      }\n    }\n    // Make sure anonymous is boolean if present.\n    // Null counts as present, and would be falsy, which is the default.\n    if (cloned.anonymous !== undefined) {\n      cloned.anonymous = !!cloned.anonymous;\n    }\n\n    return cloned;\n  };\n\n  /**\n   * @param {Object} context\n   * @param {boolean} redactAnonymous\n   * @returns {Object} A copy of the context with the private attributes removed,\n   * and the redactedAttributes meta populated for each sub-context.\n   */\n  const filterMultiKind = (context, redactAnonymous) => {\n    const filtered = {\n      kind: context.kind,\n    };\n    const contextKeys = Object.keys(context);\n\n    for (const contextKey of contextKeys) {\n      if (contextKey !== 'kind') {\n        const filteredContext = filterSingleKind(context[contextKey], redactAnonymous);\n        if (filteredContext) {\n          filtered[contextKey] = filteredContext;\n        }\n      }\n    }\n    return filtered;\n  };\n\n  /**\n   * Convert the LDUser object into an LDContext object.\n   * @param {Object} user The LDUser to produce an LDContext for.\n   * @returns {Object} A single kind context based on the provided user.\n   */\n  const legacyToSingleKind = user => {\n    const filtered = {\n      /* Destructure custom items into the top level.\n         Duplicate keys will be overridden by previously\n         top level items.\n      */\n      ...(user.custom || {}),\n\n      // Implicity a user kind.\n      kind: 'user',\n\n      key: user.key,\n    };\n\n    if (user.anonymous !== undefined) {\n      filtered.anonymous = !!user.anonymous;\n    }\n\n    // Copy top level keys and convert them to strings.\n    // Remove keys that may have been destructured from `custom`.\n    for (const key of legacyTopLevelCopyAttributes) {\n      delete filtered[key];\n      if (user[key] !== undefined && user[key] !== null) {\n        filtered[key] = String(user[key]);\n      }\n    }\n\n    if (user.privateAttributeNames !== undefined && user.privateAttributeNames !== null) {\n      filtered._meta = filtered._meta || {};\n      // If any private attributes started with '/' we need to convert them to references, otherwise the '/' will\n      // cause the literal to incorrectly be treated as a reference.\n      filtered._meta.privateAttributes = user.privateAttributeNames.map(literal =>\n        literal.startsWith('/') ? AttributeReference.literalToReference(literal) : literal\n      );\n    }\n\n    return filtered;\n  };\n\n  filter.filter = (context, redactAnonymous = false) => {\n    if (context.kind === undefined || context.kind === null) {\n      return filterSingleKind(legacyToSingleKind(context), redactAnonymous);\n    } else if (context.kind === 'multi') {\n      return filterMultiKind(context, redactAnonymous);\n    } else {\n      return filterSingleKind(context, redactAnonymous);\n    }\n  };\n\n  return filter;\n}\n\nmodule.exports = ContextFilter;\n","const EventSender = require('./EventSender');\nconst EventSummarizer = require('./EventSummarizer');\nconst ContextFilter = require('./ContextFilter');\nconst errors = require('./errors');\nconst messages = require('./messages');\nconst utils = require('./utils');\nconst { getContextKeys } = require('./context');\n\nfunction EventProcessor(\n  platform,\n  options,\n  environmentId,\n  diagnosticsAccumulator = null,\n  emitter = null,\n  sender = null\n) {\n  const processor = {};\n  const eventSender = sender || EventSender(platform, environmentId, options);\n  const mainEventsUrl = utils.appendUrlPath(options.eventsUrl, '/events/bulk/' + environmentId);\n  const summarizer = EventSummarizer();\n  const contextFilter = ContextFilter(options);\n  const samplingInterval = options.samplingInterval;\n  const eventCapacity = options.eventCapacity;\n  const flushInterval = options.flushInterval;\n  const logger = options.logger;\n  let queue = [];\n  let lastKnownPastTime = 0;\n  let disabled = false;\n  let exceededCapacity = false;\n  let flushTimer;\n\n  function shouldSampleEvent() {\n    return samplingInterval === 0 || Math.floor(Math.random() * samplingInterval) === 0;\n  }\n\n  function shouldDebugEvent(e) {\n    if (e.debugEventsUntilDate) {\n      // The \"last known past time\" comes from the last HTTP response we got from the server.\n      // In case the client's time is set wrong, at least we know that any expiration date\n      // earlier than that point is definitely in the past.  If there's any discrepancy, we\n      // want to err on the side of cutting off event debugging sooner.\n      return e.debugEventsUntilDate > lastKnownPastTime && e.debugEventsUntilDate > new Date().getTime();\n    }\n    return false;\n  }\n\n  // Transform an event from its internal format to the format we use when sending a payload.\n  function makeOutputEvent(e) {\n    const ret = utils.extend({}, e);\n    if (e.kind === 'identify') {\n      // identify events always have an inline context\n      ret.context = contextFilter.filter(e.context);\n    } else if (e.kind === 'feature') {\n      // feature events always have an inline context\n      ret.context = contextFilter.filter(e.context, true);\n    } else {\n      ret.contextKeys = getContextKeysFromEvent(e);\n      delete ret['context'];\n    }\n    if (e.kind === 'feature') {\n      delete ret['trackEvents'];\n      delete ret['debugEventsUntilDate'];\n    }\n    return ret;\n  }\n\n  function getContextKeysFromEvent(event) {\n    return getContextKeys(event.context, logger);\n  }\n\n  function addToOutbox(event) {\n    if (queue.length < eventCapacity) {\n      queue.push(event);\n      exceededCapacity = false;\n    } else {\n      if (!exceededCapacity) {\n        exceededCapacity = true;\n        logger.warn(messages.eventCapacityExceeded());\n      }\n      if (diagnosticsAccumulator) {\n        // For diagnostic events, we track how many times we had to drop an event due to exceeding the capacity.\n        diagnosticsAccumulator.incrementDroppedEvents();\n      }\n    }\n  }\n\n  processor.enqueue = function(event) {\n    if (disabled) {\n      return;\n    }\n    let addFullEvent = false;\n    let addDebugEvent = false;\n\n    // Add event to the summary counters if appropriate\n    summarizer.summarizeEvent(event);\n\n    // Decide whether to add the event to the payload. Feature events may be added twice, once for\n    // the event (if tracked) and once for debugging.\n    if (event.kind === 'feature') {\n      if (shouldSampleEvent()) {\n        addFullEvent = !!event.trackEvents;\n        addDebugEvent = shouldDebugEvent(event);\n      }\n    } else {\n      addFullEvent = shouldSampleEvent();\n    }\n\n    if (addFullEvent) {\n      addToOutbox(makeOutputEvent(event));\n    }\n    if (addDebugEvent) {\n      const debugEvent = utils.extend({}, event, { kind: 'debug' });\n      debugEvent.context = contextFilter.filter(debugEvent.context);\n      delete debugEvent['trackEvents'];\n      delete debugEvent['debugEventsUntilDate'];\n      addToOutbox(debugEvent);\n    }\n  };\n\n  processor.flush = function() {\n    if (disabled) {\n      return Promise.resolve();\n    }\n    const eventsToSend = queue;\n    const summary = summarizer.getSummary();\n    summarizer.clearSummary();\n    if (summary) {\n      summary.kind = 'summary';\n      eventsToSend.push(summary);\n    }\n    if (diagnosticsAccumulator) {\n      // For diagnostic events, we record how many events were in the queue at the last flush (since \"how\n      // many events happened to be in the queue at the moment we decided to send a diagnostic event\" would\n      // not be a very useful statistic).\n      diagnosticsAccumulator.setEventsInLastBatch(eventsToSend.length);\n    }\n    if (eventsToSend.length === 0) {\n      return Promise.resolve();\n    }\n    queue = [];\n    logger.debug(messages.debugPostingEvents(eventsToSend.length));\n    return eventSender.sendEvents(eventsToSend, mainEventsUrl).then(responseInfo => {\n      if (responseInfo) {\n        if (responseInfo.serverTime) {\n          lastKnownPastTime = responseInfo.serverTime;\n        }\n        if (!errors.isHttpErrorRecoverable(responseInfo.status)) {\n          disabled = true;\n        }\n        if (responseInfo.status >= 400) {\n          utils.onNextTick(() => {\n            emitter.maybeReportError(\n              new errors.LDUnexpectedResponseError(\n                messages.httpErrorMessage(responseInfo.status, 'event posting', 'some events were dropped')\n              )\n            );\n          });\n        }\n      }\n    });\n  };\n\n  processor.start = function() {\n    const flushTick = () => {\n      processor.flush();\n      flushTimer = setTimeout(flushTick, flushInterval);\n    };\n    flushTimer = setTimeout(flushTick, flushInterval);\n  };\n\n  processor.stop = function() {\n    clearTimeout(flushTimer);\n  };\n\n  return processor;\n}\n\nmodule.exports = EventProcessor;\n","function EventEmitter(logger) {\n  const emitter = {};\n  const events = {};\n\n  const listeningTo = event => !!events[event];\n\n  emitter.on = function(event, handler, context) {\n    events[event] = events[event] || [];\n    events[event] = events[event].concat({\n      handler: handler,\n      context: context,\n    });\n  };\n\n  emitter.off = function(event, handler, context) {\n    if (!events[event]) {\n      return;\n    }\n    for (let i = 0; i < events[event].length; i++) {\n      if (events[event][i].handler === handler && events[event][i].context === context) {\n        events[event] = events[event].slice(0, i).concat(events[event].slice(i + 1));\n      }\n    }\n  };\n\n  emitter.emit = function(event) {\n    if (!events[event]) {\n      return;\n    }\n    // Copy the list of handlers before iterating, in case any handler adds or removes another handler.\n    // Any such changes should not affect what we do here-- we want to notify every handler that existed\n    // at the moment that the event was fired.\n    const copiedHandlers = events[event].slice(0);\n    for (let i = 0; i < copiedHandlers.length; i++) {\n      copiedHandlers[i].handler.apply(copiedHandlers[i].context, Array.prototype.slice.call(arguments, 1));\n    }\n  };\n\n  emitter.getEvents = function() {\n    return Object.keys(events);\n  };\n\n  emitter.getEventListenerCount = function(event) {\n    return events[event] ? events[event].length : 0;\n  };\n\n  emitter.maybeReportError = function(error) {\n    if (!error) {\n      return;\n    }\n    if (listeningTo('error')) {\n      this.emit('error', error);\n    } else {\n      (logger || console).error(error.message);\n    }\n  };\n  return emitter;\n}\n\nmodule.exports = EventEmitter;\n","// This file provides an abstraction of the client's startup state.\n//\n// Startup can either succeed or fail exactly once; calling signalSuccess() or signalFailure()\n// after that point has no effect.\n//\n// On success, we fire both an \"initialized\" event and a \"ready\" event. Both the waitForInitialization()\n// promise and the waitUntilReady() promise are resolved in this case.\n//\n// On failure, we fire both a \"failed\" event (with the error as a parameter) and a \"ready\" event.\n// The waitForInitialization() promise is rejected, but the waitUntilReady() promise is resolved.\n//\n// To complicate things, we must *not* create the waitForInitialization() promise unless it is\n// requested, because otherwise failures would cause an *unhandled* rejection which can be a\n// serious problem in some environments. So we use a somewhat roundabout system for tracking the\n// initialization state and lazily creating this promise.\n\nconst readyEvent = 'ready',\n  successEvent = 'initialized',\n  failureEvent = 'failed';\n\nfunction InitializationStateTracker(eventEmitter) {\n  let succeeded = false,\n    failed = false,\n    failureValue = null,\n    initializationPromise = null;\n\n  const readyPromise = new Promise(resolve => {\n    const onReady = () => {\n      eventEmitter.off(readyEvent, onReady); // we can't use \"once\" because it's not available on some JS platforms\n      resolve();\n    };\n    eventEmitter.on(readyEvent, onReady);\n  }).catch(() => {}); // this Promise should never be rejected, but the catch handler is a safety measure\n\n  return {\n    getInitializationPromise: () => {\n      if (initializationPromise) {\n        return initializationPromise;\n      }\n      if (succeeded) {\n        return Promise.resolve();\n      }\n      if (failed) {\n        return Promise.reject(failureValue);\n      }\n      initializationPromise = new Promise((resolve, reject) => {\n        const onSuccess = () => {\n          eventEmitter.off(successEvent, onSuccess);\n          resolve();\n        };\n        const onFailure = err => {\n          eventEmitter.off(failureEvent, onFailure);\n          reject(err);\n        };\n        eventEmitter.on(successEvent, onSuccess);\n        eventEmitter.on(failureEvent, onFailure);\n      });\n      return initializationPromise;\n    },\n\n    getReadyPromise: () => readyPromise,\n\n    signalSuccess: () => {\n      if (!succeeded && !failed) {\n        succeeded = true;\n        eventEmitter.emit(successEvent);\n        eventEmitter.emit(readyEvent);\n      }\n    },\n\n    signalFailure: err => {\n      if (!succeeded && !failed) {\n        failed = true;\n        failureValue = err;\n        eventEmitter.emit(failureEvent, err);\n        eventEmitter.emit(readyEvent);\n      }\n      eventEmitter.maybeReportError(err); // the \"error\" event can be emitted more than once, unlike the others\n    },\n  };\n}\n\nmodule.exports = InitializationStateTracker;\n","const utils = require('./utils');\n\nfunction PersistentFlagStore(storage, environment, hash, ident) {\n  const store = {};\n\n  function getFlagsKey() {\n    let key = '';\n    const context = ident.getContext();\n    if (context) {\n      key = hash || utils.btoa(JSON.stringify(context));\n    }\n    return 'ld:' + environment + ':' + key;\n  }\n\n  // Returns a Promise which will be resolved with a parsed JSON value if a stored value was available,\n  // or resolved with null if there was no value or if storage was not available.\n  store.loadFlags = () =>\n    storage.get(getFlagsKey()).then(dataStr => {\n      if (dataStr === null || dataStr === undefined) {\n        return null;\n      }\n      try {\n        let data = JSON.parse(dataStr);\n        if (data) {\n          const schema = data.$schema;\n          if (schema === undefined || schema < 1) {\n            data = utils.transformValuesToVersionedValues(data);\n          } else {\n            delete data['$schema'];\n          }\n        }\n        return data;\n      } catch (ex) {\n        return store.clearFlags().then(() => null);\n      }\n    });\n\n  // Resolves with true if successful, or false if storage is unavailable. Never rejects.\n  store.saveFlags = flags => {\n    const data = utils.extend({}, flags, { $schema: 1 });\n    return storage.set(getFlagsKey(), JSON.stringify(data));\n  };\n\n  // Resolves with true if successful, or false if storage is unavailable. Never rejects.\n  store.clearFlags = () => storage.clear(getFlagsKey());\n\n  return store;\n}\n\nmodule.exports = PersistentFlagStore;\n","const messages = require('./messages');\n\n// The localStorageProvider is provided by the platform object. It should have the following\n// methods, each of which should return a Promise:\n// - get(key): Gets the string value, if any, for the given key\n// - set(key, value): Stores a string value for the given key\n// - remove(key): Removes the given key\n//\n// Storage is just a light wrapper of the localStorageProvider, adding error handling and\n// ensuring that we don't call it if it's unavailable. The get method will simply resolve\n// with an undefined value if there is an error or if there is no localStorageProvider.\n// None of the promises returned by Storage will ever be rejected.\n//\n// It is always possible that the underlying platform storage mechanism might fail or be\n// disabled. If so, it's likely that it will keep failing, so we will only log one warning\n// instead of repetitive warnings.\nfunction PersistentStorage(localStorageProvider, logger) {\n  const storage = {};\n  let loggedError = false;\n\n  const logError = err => {\n    if (!loggedError) {\n      loggedError = true;\n      logger.warn(messages.localStorageUnavailable(err));\n    }\n  };\n\n  storage.isEnabled = () => !!localStorageProvider;\n\n  // Resolves with a value, or undefined if storage is unavailable. Never rejects.\n  storage.get = key =>\n    new Promise(resolve => {\n      if (!localStorageProvider) {\n        resolve(undefined);\n        return;\n      }\n      localStorageProvider\n        .get(key)\n        .then(resolve)\n        .catch(err => {\n          logError(err);\n          resolve(undefined);\n        });\n    });\n\n  // Resolves with true if successful, or false if storage is unavailable. Never rejects.\n  storage.set = (key, value) =>\n    new Promise(resolve => {\n      if (!localStorageProvider) {\n        resolve(false);\n        return;\n      }\n      localStorageProvider\n        .set(key, value)\n        .then(() => resolve(true))\n        .catch(err => {\n          logError(err);\n          resolve(false);\n        });\n    });\n\n  // Resolves with true if successful, or false if storage is unavailable. Never rejects.\n  storage.clear = key =>\n    new Promise(resolve => {\n      if (!localStorageProvider) {\n        resolve(false);\n        return;\n      }\n      localStorageProvider\n        .clear(key)\n        .then(() => resolve(true))\n        .catch(err => {\n          logError(err);\n          resolve(false);\n        });\n    });\n\n  return storage;\n}\n\nmodule.exports = PersistentStorage;\n","const messages = require('./messages');\nconst { appendUrlPath, base64URLEncode, objectHasOwnProperty } = require('./utils');\nconst { getLDHeaders, transformHeaders } = require('./headers');\nconst { isHttpErrorRecoverable } = require('./errors');\n\n// The underlying event source implementation is abstracted via the platform object, which should\n// have these three properties:\n// eventSourceFactory(): a function that takes a URL and optional config object and returns an object\n//   with the same methods as the regular HTML5 EventSource object. The properties in the config\n//   object are those supported by the launchdarkly-eventsource package; browser EventSource\n//   implementations don't have any config options.\n// eventSourceIsActive(): a function that takes an EventSource-compatible object and returns true if\n//   it is in an active state (connected or connecting).\n// eventSourceAllowsReport: true if REPORT is supported.\n\n// The read timeout for the stream is a fixed value that is set to be slightly longer than the expected\n// interval between heartbeats from the LaunchDarkly streaming server. If this amount of time elapses\n// with no new data, the connection will be cycled.\nconst streamReadTimeoutMillis = 5 * 60 * 1000; // 5 minutes\nconst maxRetryDelay = 30 * 1000; // Maximum retry delay 30 seconds.\nconst jitterRatio = 0.5; // Delay should be 50%-100% of calculated time.\n\nfunction Stream(platform, config, environment, diagnosticsAccumulator) {\n  const baseUrl = config.streamUrl;\n  const logger = config.logger;\n  const stream = {};\n  const evalUrlPrefix = appendUrlPath(baseUrl, '/eval/' + environment);\n  const useReport = config.useReport;\n  const withReasons = config.evaluationReasons;\n  const baseReconnectDelay = config.streamReconnectDelay;\n  const headers = getLDHeaders(platform, config);\n  let firstConnectionErrorLogged = false;\n  let es = null;\n  let reconnectTimeoutReference = null;\n  let connectionAttemptStartTime;\n  let context = null;\n  let hash = null;\n  let handlers = null;\n  let retryCount = 0;\n\n  function backoff() {\n    const delay = baseReconnectDelay * Math.pow(2, retryCount);\n    return delay > maxRetryDelay ? maxRetryDelay : delay;\n  }\n\n  function jitter(computedDelayMillis) {\n    return computedDelayMillis - Math.trunc(Math.random() * jitterRatio * computedDelayMillis);\n  }\n\n  function getNextRetryDelay() {\n    const delay = jitter(backoff());\n    retryCount += 1;\n    return delay;\n  }\n\n  stream.connect = function(newContext, newHash, newHandlers) {\n    context = newContext;\n    hash = newHash;\n    handlers = {};\n    for (const key in newHandlers || {}) {\n      handlers[key] = function(e) {\n        // Reset the state for logging the first connection error so that the first\n        // connection error following a successful connection will once again be logged.\n        // We will decorate *all* handlers to do this to keep this abstraction agnostic\n        // for different stream implementations.\n        firstConnectionErrorLogged = false;\n        logConnectionResult(true);\n        newHandlers[key] && newHandlers[key](e);\n      };\n    }\n    tryConnect();\n  };\n\n  stream.disconnect = function() {\n    clearTimeout(reconnectTimeoutReference);\n    reconnectTimeoutReference = null;\n    closeConnection();\n  };\n\n  stream.isConnected = function() {\n    return !!(es && platform.eventSourceIsActive && platform.eventSourceIsActive(es));\n  };\n\n  function handleError(err) {\n    // The event source may not produce a status. But the LaunchDarkly\n    // polyfill can. If we can get the status, then we should stop retrying\n    // on certain error codes.\n    if (err.status && typeof err.status === 'number' && !isHttpErrorRecoverable(err.status)) {\n      // If we encounter an unrecoverable condition, then we do not want to\n      // retry anymore.\n      closeConnection();\n      logger.error(messages.unrecoverableStreamError(err));\n      // Ensure any pending retry attempts are not done.\n      if (reconnectTimeoutReference) {\n        clearTimeout(reconnectTimeoutReference);\n        reconnectTimeoutReference = null;\n      }\n      return;\n    }\n\n    const delay = getNextRetryDelay();\n\n    if (!firstConnectionErrorLogged) {\n      logger.warn(messages.streamError(err, delay));\n      firstConnectionErrorLogged = true;\n    }\n    logConnectionResult(false);\n    closeConnection();\n    tryConnect(delay);\n  }\n\n  function tryConnect(delay) {\n    if (!reconnectTimeoutReference) {\n      if (delay) {\n        reconnectTimeoutReference = setTimeout(openConnection, delay);\n      } else {\n        openConnection();\n      }\n    }\n  }\n\n  function openConnection() {\n    reconnectTimeoutReference = null;\n    let url;\n    let query = '';\n    const options = { headers, readTimeoutMillis: streamReadTimeoutMillis };\n    if (platform.eventSourceFactory) {\n      if (hash !== null && hash !== undefined) {\n        query = 'h=' + hash;\n      }\n      if (useReport) {\n        if (platform.eventSourceAllowsReport) {\n          url = evalUrlPrefix;\n          options.method = 'REPORT';\n          options.headers['Content-Type'] = 'application/json';\n          options.body = JSON.stringify(context);\n        } else {\n          // if we can't do REPORT, fall back to the old ping-based stream\n          url = appendUrlPath(baseUrl, '/ping/' + environment);\n          query = '';\n        }\n      } else {\n        url = evalUrlPrefix + '/' + base64URLEncode(JSON.stringify(context));\n      }\n      options.headers = transformHeaders(options.headers, config);\n      if (withReasons) {\n        query = query + (query ? '&' : '') + 'withReasons=true';\n      }\n      url = url + (query ? '?' : '') + query;\n\n      closeConnection();\n      logger.info(messages.streamConnecting(url));\n      logConnectionStarted();\n\n      es = platform.eventSourceFactory(url, options);\n      for (const key in handlers) {\n        if (objectHasOwnProperty(handlers, key)) {\n          es.addEventListener(key, handlers[key]);\n        }\n      }\n\n      es.onerror = handleError;\n\n      es.onopen = () => {\n        // If the connection is a success, then reset the retryCount.\n        retryCount = 0;\n      };\n    }\n  }\n\n  function closeConnection() {\n    if (es) {\n      logger.info(messages.streamClosing());\n      es.close();\n      es = null;\n    }\n  }\n\n  function logConnectionStarted() {\n    connectionAttemptStartTime = new Date().getTime();\n  }\n\n  function logConnectionResult(success) {\n    if (connectionAttemptStartTime && diagnosticsAccumulator) {\n      diagnosticsAccumulator.recordStreamInit(\n        connectionAttemptStartTime,\n        !success,\n        new Date().getTime() - connectionAttemptStartTime\n      );\n    }\n    connectionAttemptStartTime = null;\n  }\n\n  return stream;\n}\n\nmodule.exports = Stream;\n","// This function allows a series of Promises to be coalesced such that only the most recently\n// added one actually matters. For instance, if several HTTP requests are made to the same\n// endpoint and we want to ensure that whoever made each one always gets the latest data, each\n// can be passed to addPromise (on the same coalescer) and each caller can wait on the\n// coalescer.resultPromise; all three will then receive the result (or error) from the *last*\n// request, and the results of the first two will be discarded.\n//\n// The cancelFn callback, if present, will be called whenever an existing promise is being\n// discarded. This can be used for instance to abort an HTTP request that's now obsolete.\n//\n// The finallyFn callback, if present, is called on completion of the whole thing. This is\n// different from calling coalescer.resultPromise.finally() because it is executed before any\n// other handlers. Its purpose is to tell the caller that this coalescer should no longer be used.\n\nfunction promiseCoalescer(finallyFn) {\n  let currentPromise;\n  let currentCancelFn;\n  let finalResolve;\n  let finalReject;\n\n  const coalescer = {};\n\n  coalescer.addPromise = (p, cancelFn) => {\n    currentPromise = p;\n    currentCancelFn && currentCancelFn();\n    currentCancelFn = cancelFn;\n\n    p.then(\n      result => {\n        if (currentPromise === p) {\n          finalResolve(result);\n          finallyFn && finallyFn();\n        }\n      },\n      error => {\n        if (currentPromise === p) {\n          finalReject(error);\n          finallyFn && finallyFn();\n        }\n      }\n    );\n  };\n\n  coalescer.resultPromise = new Promise((resolve, reject) => {\n    finalResolve = resolve;\n    finalReject = reject;\n  });\n\n  return coalescer;\n}\n\nmodule.exports = promiseCoalescer;\n","const utils = require('./utils');\nconst errors = require('./errors');\nconst messages = require('./messages');\nconst promiseCoalescer = require('./promiseCoalescer');\nconst { transformHeaders, getLDHeaders } = require('./headers');\n\nconst jsonContentType = 'application/json';\n\nfunction getResponseError(result) {\n  if (result.status === 404) {\n    return new errors.LDInvalidEnvironmentIdError(messages.environmentNotFound());\n  } else {\n    return new errors.LDFlagFetchError(messages.errorFetchingFlags(result.statusText || String(result.status)));\n  }\n}\n\nfunction Requestor(platform, options, environment) {\n  const baseUrl = options.baseUrl;\n  const useReport = options.useReport;\n  const withReasons = options.evaluationReasons;\n  const logger = options.logger;\n\n  const requestor = {};\n\n  const activeRequests = {}; // map of URLs to promiseCoalescers\n\n  function fetchJSON(endpoint, body) {\n    if (!platform.httpRequest) {\n      return new Promise((resolve, reject) => {\n        reject(new errors.LDFlagFetchError(messages.httpUnavailable()));\n      });\n    }\n\n    const method = body ? 'REPORT' : 'GET';\n    const headers = getLDHeaders(platform, options);\n    if (body) {\n      headers['Content-Type'] = jsonContentType;\n    }\n\n    let coalescer = activeRequests[endpoint];\n    if (!coalescer) {\n      coalescer = promiseCoalescer(() => {\n        // this will be called once there are no more active requests for the same endpoint\n        delete activeRequests[endpoint];\n      });\n      activeRequests[endpoint] = coalescer;\n    }\n\n    const req = platform.httpRequest(method, endpoint, transformHeaders(headers, options), body);\n    const p = req.promise.then(\n      result => {\n        if (result.status === 200) {\n          // We're using substring here because using startsWith would require a polyfill in IE.\n          if (\n            result.header('content-type') &&\n            result.header('content-type').substring(0, jsonContentType.length) === jsonContentType\n          ) {\n            return JSON.parse(result.body);\n          } else {\n            const message = messages.invalidContentType(result.header('content-type') || '');\n            return Promise.reject(new errors.LDFlagFetchError(message));\n          }\n        } else {\n          return Promise.reject(getResponseError(result));\n        }\n      },\n      e => Promise.reject(new errors.LDFlagFetchError(messages.networkError(e)))\n    );\n    coalescer.addPromise(p, () => {\n      // this will be called if another request for the same endpoint supersedes this one\n      req.cancel && req.cancel();\n    });\n    return coalescer.resultPromise;\n  }\n\n  // Performs a GET request to an arbitrary path under baseUrl. Returns a Promise which will resolve\n  // with the parsed JSON response, or will be rejected if the request failed.\n  requestor.fetchJSON = function(path) {\n    return fetchJSON(utils.appendUrlPath(baseUrl, path), null);\n  };\n\n  // Requests the current state of all flags for the given context from LaunchDarkly. Returns a Promise\n  // which will resolve with the parsed JSON response, or will be rejected if the request failed.\n  requestor.fetchFlagSettings = function(context, hash) {\n    let data;\n    let endpoint;\n    let query = '';\n    let body;\n\n    if (useReport) {\n      endpoint = [baseUrl, '/sdk/evalx/', environment, '/context'].join('');\n      body = JSON.stringify(context);\n    } else {\n      data = utils.base64URLEncode(JSON.stringify(context));\n      endpoint = [baseUrl, '/sdk/evalx/', environment, '/contexts/', data].join('');\n    }\n    if (hash) {\n      query = 'h=' + hash;\n    }\n    if (withReasons) {\n      query = query + (query ? '&' : '') + 'withReasons=true';\n    }\n    endpoint = endpoint + (query ? '?' : '') + query;\n    logger.debug(messages.debugPolling(endpoint));\n\n    return fetchJSON(endpoint, body);\n  };\n\n  return requestor;\n}\n\nmodule.exports = Requestor;\n","const utils = require('./utils');\n\nfunction Identity(initialContext, onChange) {\n  const ident = {};\n  let context;\n\n  ident.setContext = function(c) {\n    context = utils.sanitizeContext(c);\n    if (context && onChange) {\n      onChange(utils.clone(context));\n    }\n  };\n\n  ident.getContext = function() {\n    return context ? utils.clone(context) : null;\n  };\n\n  if (initialContext) {\n    ident.setContext(initialContext);\n  }\n\n  return ident;\n}\n\nmodule.exports = Identity;\n","const { v1: uuidv1 } = require('uuid');\nconst { getContextKinds } = require('./context');\n\nconst errors = require('./errors');\nconst messages = require('./messages');\nconst utils = require('./utils');\n\nconst ldUserIdKey = 'ld:$anonUserId';\n\n/**\n * Create an object which can process a context and populate any required keys\n * for anonymous objects.\n *\n * @param {Object} persistentStorage The persistent storage from which to store\n * and access persisted anonymous context keys.\n * @returns An AnonymousContextProcessor.\n */\nfunction AnonymousContextProcessor(persistentStorage) {\n  function getContextKeyIdString(kind) {\n    if (kind === undefined || kind === null || kind === 'user') {\n      return ldUserIdKey;\n    }\n    return `ld:$contextKey:${kind}`;\n  }\n\n  function getCachedContextKey(kind) {\n    return persistentStorage.get(getContextKeyIdString(kind));\n  }\n\n  function setCachedContextKey(id, kind) {\n    return persistentStorage.set(getContextKeyIdString(kind), id);\n  }\n\n  /**\n   * Process a single kind context, or a single context within a multi-kind context.\n   * @param {string} kind The kind of the context. Independent because the kind is not prevent\n   * within a context in a multi-kind context.\n   * @param {Object} context\n   * @returns {Promise} a promise that resolves to a processed contexts, or rejects\n   * a context which cannot be processed.\n   */\n  function processSingleKindContext(kind, context) {\n    // We are working on a copy of an original context, so we want to re-assign\n    // versus duplicating it again.\n\n    /* eslint-disable no-param-reassign */\n    if (context.key !== null && context.key !== undefined) {\n      context.key = context.key.toString();\n      return Promise.resolve(context);\n    }\n\n    if (context.anonymous) {\n      // If the key doesn't exist, then the persistent storage will resolve\n      // with undefined.\n      return getCachedContextKey(kind).then(cachedId => {\n        if (cachedId) {\n          context.key = cachedId;\n          return context;\n        } else {\n          const id = uuidv1();\n          context.key = id;\n          return setCachedContextKey(id, kind).then(() => context);\n        }\n      });\n    } else {\n      return Promise.reject(new errors.LDInvalidUserError(messages.invalidContext()));\n    }\n    /* eslint-enable no-param-reassign */\n  }\n\n  /**\n   * Process the context, returning a Promise that resolves to the processed context, or rejects if there is an error.\n   * @param {Object} context\n   * @returns {Promise} A promise which resolves to a processed context, or a rejection if the context cannot be\n   * processed. The context should still be checked for overall validity after being processed.\n   */\n  this.processContext = context => {\n    if (!context) {\n      return Promise.reject(new errors.LDInvalidUserError(messages.contextNotSpecified()));\n    }\n\n    const processedContext = utils.clone(context);\n\n    if (context.kind === 'multi') {\n      const kinds = getContextKinds(processedContext);\n\n      return Promise.all(kinds.map(kind => processSingleKindContext(kind, processedContext[kind]))).then(\n        () => processedContext\n      );\n    }\n    return processSingleKindContext(context.kind, processedContext);\n  };\n}\n\nmodule.exports = AnonymousContextProcessor;\n","const { v1: uuidv1 } = require('uuid');\n// Note that in the diagnostic events spec, these IDs are to be generated with UUID v4. However,\n// in JS we were already using v1 for unique context keys, so to avoid bringing in two packages we\n// will use v1 here as well.\n\nconst { baseOptionDefs } = require('./configuration');\nconst messages = require('./messages');\nconst { appendUrlPath } = require('./utils');\n\nfunction DiagnosticId(sdkKey) {\n  const ret = {\n    diagnosticId: uuidv1(),\n  };\n  if (sdkKey) {\n    ret.sdkKeySuffix = sdkKey.length > 6 ? sdkKey.substring(sdkKey.length - 6) : sdkKey;\n  }\n  return ret;\n}\n\n// A stateful object holding statistics that will go into diagnostic events.\n\nfunction DiagnosticsAccumulator(startTime) {\n  let dataSinceDate, droppedEvents, eventsInLastBatch, streamInits;\n\n  function reset(time) {\n    dataSinceDate = time;\n    droppedEvents = 0;\n    eventsInLastBatch = 0;\n    streamInits = [];\n  }\n\n  reset(startTime);\n\n  return {\n    getProps: () => ({\n      dataSinceDate,\n      droppedEvents,\n      eventsInLastBatch,\n      streamInits,\n      // omit deduplicatedUsers for the JS SDKs because they don't deduplicate users\n    }),\n    setProps: props => {\n      dataSinceDate = props.dataSinceDate;\n      droppedEvents = props.droppedEvents || 0;\n      eventsInLastBatch = props.eventsInLastBatch || 0;\n      streamInits = props.streamInits || [];\n    },\n    incrementDroppedEvents: () => {\n      droppedEvents++;\n    },\n    setEventsInLastBatch: n => {\n      eventsInLastBatch = n;\n    },\n    recordStreamInit: (timestamp, failed, durationMillis) => {\n      const info = { timestamp, failed, durationMillis };\n      streamInits.push(info);\n    },\n    reset,\n  };\n}\n\n// An object that maintains information that will go into diagnostic events, and knows how to format\n// those events. It is instantiated by the SDK client, and shared with the event processor.\n//\n// The JS-based SDKs have two modes for diagnostic events. By default, the behavior is basically the\n// same as the server-side SDKs: a \"diagnostic-init\" event is sent on startup, and then \"diagnostic\"\n// events with operating statistics are sent periodically. However, in a browser environment this is\n// undesirable because the page may be reloaded frequently. In that case, setting the property\n// \"platform.diagnosticUseCombinedEvent\" to true enables an alternate mode in which a combination of\n// both kinds of event is sent at intervals, relative to the last time this was done (if any) which\n// is cached in local storage.\n\nfunction DiagnosticsManager(\n  platform,\n  persistentStorage,\n  accumulator,\n  eventSender,\n  environmentId,\n  config,\n  diagnosticId\n) {\n  const combinedMode = !!platform.diagnosticUseCombinedEvent;\n  const localStorageKey = 'ld:' + environmentId + ':$diagnostics';\n  const diagnosticEventsUrl = appendUrlPath(config.eventsUrl, '/events/diagnostic/' + environmentId);\n  const periodicInterval = config.diagnosticRecordingInterval;\n  const acc = accumulator;\n  const initialEventSamplingInterval = 4; // used only in combined mode - see start()\n  let streamingEnabled = !!config.streaming;\n  let eventSentTime;\n  let periodicTimer;\n  const manager = {};\n\n  function makeInitProperties() {\n    return {\n      sdk: makeSdkData(),\n      configuration: makeConfigData(),\n      platform: platform.diagnosticPlatformData,\n    };\n  }\n\n  // Send a diagnostic event and do not wait for completion.\n  function sendDiagnosticEvent(event) {\n    config.logger && config.logger.debug(messages.debugPostingDiagnosticEvent(event));\n    eventSender\n      .sendEvents(event, diagnosticEventsUrl, true)\n      .then(() => undefined)\n      .catch(() => undefined);\n  }\n\n  function loadProperties(callback) {\n    if (!persistentStorage.isEnabled()) {\n      return callback(false); // false indicates that local storage is not available\n    }\n    persistentStorage\n      .get(localStorageKey)\n      .then(data => {\n        if (data) {\n          try {\n            const props = JSON.parse(data);\n            acc.setProps(props);\n            eventSentTime = props.dataSinceDate;\n          } catch (e) {\n            // disregard malformed cached data\n          }\n        }\n        callback(true);\n      })\n      .catch(() => {\n        callback(false);\n      });\n  }\n\n  function saveProperties() {\n    if (persistentStorage.isEnabled()) {\n      const props = { ...acc.getProps() };\n      persistentStorage.set(localStorageKey, JSON.stringify(props));\n    }\n  }\n\n  // Creates the initial event that is sent by the event processor when the SDK starts up. This will not\n  // be repeated during the lifetime of the SDK client. In combined mode, we don't send this.\n  function createInitEvent() {\n    return {\n      kind: 'diagnostic-init',\n      id: diagnosticId,\n      creationDate: acc.getProps().dataSinceDate,\n      ...makeInitProperties(),\n    };\n  }\n\n  // Creates a periodic event containing time-dependent stats, and resets the state of the manager with\n  // regard to those stats. In combined mode (browser SDK) this also contains the configuration data.\n  function createPeriodicEventAndReset() {\n    const currentTime = new Date().getTime();\n    let ret = {\n      kind: combinedMode ? 'diagnostic-combined' : 'diagnostic',\n      id: diagnosticId,\n      creationDate: currentTime,\n      ...acc.getProps(),\n    };\n    if (combinedMode) {\n      ret = { ...ret, ...makeInitProperties() };\n    }\n    acc.reset(currentTime);\n    return ret;\n  }\n\n  function sendPeriodicEvent() {\n    sendDiagnosticEvent(createPeriodicEventAndReset());\n    periodicTimer = setTimeout(sendPeriodicEvent, periodicInterval);\n    eventSentTime = new Date().getTime();\n    if (combinedMode) {\n      saveProperties();\n    }\n  }\n\n  function makeSdkData() {\n    const sdkData = { ...platform.diagnosticSdkData };\n    if (config.wrapperName) {\n      sdkData.wrapperName = config.wrapperName;\n    }\n    if (config.wrapperVersion) {\n      sdkData.wrapperVersion = config.wrapperVersion;\n    }\n    return sdkData;\n  }\n\n  function makeConfigData() {\n    const configData = {\n      customBaseURI: config.baseUrl !== baseOptionDefs.baseUrl.default,\n      customStreamURI: config.streamUrl !== baseOptionDefs.streamUrl.default,\n      customEventsURI: config.eventsUrl !== baseOptionDefs.eventsUrl.default,\n      eventsCapacity: config.eventCapacity,\n      eventsFlushIntervalMillis: config.flushInterval,\n      reconnectTimeMillis: config.streamReconnectDelay,\n      streamingDisabled: !streamingEnabled,\n      allAttributesPrivate: !!config.allAttributesPrivate,\n      diagnosticRecordingIntervalMillis: config.diagnosticRecordingInterval,\n      // The following extra properties are only provided by client-side JS SDKs:\n      usingSecureMode: !!config.hash,\n      bootstrapMode: !!config.bootstrap,\n      fetchGoalsDisabled: !config.fetchGoals,\n      sendEventsOnlyForVariation: !!config.sendEventsOnlyForVariation,\n    };\n    // Client-side JS SDKs do not have the following properties which other SDKs have:\n    // connectTimeoutMillis\n    // pollingIntervalMillis\n    // samplingInterval\n    // socketTimeoutMillis\n    // startWaitMillis\n    // userKeysCapacity\n    // userKeysFlushIntervalMillis\n    // usingProxy\n    // usingProxyAuthenticator\n    // usingRelayDaemon\n\n    return configData;\n  }\n\n  // Called when the SDK is starting up. Either send an init event immediately, or, in the alternate\n  // mode, check for cached local storage properties and send an event only if we haven't done so\n  // recently.\n  manager.start = () => {\n    if (combinedMode) {\n      loadProperties(localStorageAvailable => {\n        if (localStorageAvailable) {\n          const nextEventTime = (eventSentTime || 0) + periodicInterval;\n          const timeNow = new Date().getTime();\n          if (timeNow >= nextEventTime) {\n            sendPeriodicEvent();\n          } else {\n            periodicTimer = setTimeout(sendPeriodicEvent, nextEventTime - timeNow);\n          }\n        } else {\n          // We don't have the ability to cache anything in local storage, so we don't know if we\n          // recently sent an event before this page load, but we would still prefer not to send one\n          // on *every* page load. So, as a rough heuristic, we'll decide semi-randomly.\n          if (Math.floor(Math.random() * initialEventSamplingInterval) === 0) {\n            sendPeriodicEvent();\n          } else {\n            periodicTimer = setTimeout(sendPeriodicEvent, periodicInterval);\n          }\n        }\n      });\n    } else {\n      sendDiagnosticEvent(createInitEvent());\n      periodicTimer = setTimeout(sendPeriodicEvent, periodicInterval);\n    }\n  };\n\n  manager.stop = () => {\n    periodicTimer && clearTimeout(periodicTimer);\n  };\n\n  // Called when streaming mode is turned on or off dynamically.\n  manager.setStreaming = enabled => {\n    streamingEnabled = enabled;\n  };\n\n  return manager;\n}\n\nmodule.exports = {\n  DiagnosticId,\n  DiagnosticsAccumulator,\n  DiagnosticsManager,\n};\n","const messages = require('./messages');\n\n/**\n * Wrap an inspector ensuring that calling its methods are safe.\n * @param {object} inspector Inspector to wrap.\n */\nfunction SafeInspector(inspector, logger) {\n  let errorLogged = false;\n  const wrapper = {\n    type: inspector.type,\n    name: inspector.name,\n    synchronous: inspector.synchronous,\n  };\n\n  wrapper.method = (...args) => {\n    try {\n      inspector.method(...args);\n    } catch {\n      // If something goes wrong in an inspector we want to log that something\n      // went wrong. We don't want to flood the logs, so we only log something\n      // the first time that something goes wrong.\n      // We do not include the exception in the log, because we do not know what\n      // kind of data it may contain.\n      if (!errorLogged) {\n        errorLogged = true;\n        logger.warn(messages.inspectorMethodError(wrapper.type, wrapper.name));\n      }\n      // Prevent errors.\n    }\n  };\n\n  return wrapper;\n}\n\nmodule.exports = SafeInspector;\n","const messages = require('./messages');\nconst SafeInspector = require('./SafeInspector');\nconst { onNextTick } = require('./utils');\n\n/**\n * The types of supported inspectors.\n */\nconst InspectorTypes = {\n  flagUsed: 'flag-used',\n  flagDetailsChanged: 'flag-details-changed',\n  flagDetailChanged: 'flag-detail-changed',\n  clientIdentityChanged: 'client-identity-changed',\n};\n\nObject.freeze(InspectorTypes);\n\n/**\n * Manages dispatching of inspection data to registered inspectors.\n */\nfunction InspectorManager(inspectors, logger) {\n  const manager = {};\n\n  /**\n   * Collection of inspectors keyed by type.\n   *\n   * Inspectors are async by default.\n   *\n   * @type {{[type: string]: object[]}}\n   */\n  const inspectorsByType = {\n    [InspectorTypes.flagUsed]: [],\n    [InspectorTypes.flagDetailsChanged]: [],\n    [InspectorTypes.flagDetailChanged]: [],\n    [InspectorTypes.clientIdentityChanged]: [],\n  };\n  /**\n   * Collection synchronous of inspectors keyed by type.\n   *\n   * @type {{[type: string]: object[]}}\n   */\n  const synchronousInspectorsByType = {\n    [InspectorTypes.flagUsed]: [],\n    [InspectorTypes.flagDetailsChanged]: [],\n    [InspectorTypes.flagDetailChanged]: [],\n    [InspectorTypes.clientIdentityChanged]: [],\n  };\n\n  const safeInspectors = inspectors && inspectors.map(inspector => SafeInspector(inspector, logger));\n\n  safeInspectors &&\n    safeInspectors.forEach(safeInspector => {\n      // Only add inspectors of supported types.\n      if (Object.prototype.hasOwnProperty.call(inspectorsByType, safeInspector.type) && !safeInspector.synchronous) {\n        inspectorsByType[safeInspector.type].push(safeInspector);\n      } else if (\n        Object.prototype.hasOwnProperty.call(synchronousInspectorsByType, safeInspector.type) &&\n        safeInspector.synchronous\n      ) {\n        synchronousInspectorsByType[safeInspector.type].push(safeInspector);\n      } else {\n        logger.warn(messages.invalidInspector(safeInspector.type, safeInspector.name));\n      }\n    });\n\n  /**\n   * Check if there is an inspector of a specific type registered.\n   *\n   * @param {string} type The type of the inspector to check.\n   * @returns True if there are any inspectors of that type registered.\n   */\n  manager.hasListeners = type =>\n    (inspectorsByType[type] && inspectorsByType[type].length) ||\n    (synchronousInspectorsByType[type] && synchronousInspectorsByType[type].length);\n\n  /**\n   * Notify registered inspectors of a flag being used.\n   *\n   * The notification itself will be dispatched asynchronously.\n   *\n   * @param {string} flagKey The key for the flag.\n   * @param {Object} detail The LDEvaluationDetail for the flag.\n   * @param {Object} context The LDContext for the flag.\n   */\n  manager.onFlagUsed = (flagKey, detail, context) => {\n    const type = InspectorTypes.flagUsed;\n    if (synchronousInspectorsByType[type].length) {\n      synchronousInspectorsByType[type].forEach(inspector => inspector.method(flagKey, detail, context));\n    }\n    if (inspectorsByType[type].length) {\n      onNextTick(() => {\n        inspectorsByType[type].forEach(inspector => inspector.method(flagKey, detail, context));\n      });\n    }\n  };\n\n  /**\n   * Notify registered inspectors that the flags have been replaced.\n   *\n   * The notification itself will be dispatched asynchronously.\n   *\n   * @param {Record<string, Object>} flags The current flags as a Record<string, LDEvaluationDetail>.\n   */\n  manager.onFlags = flags => {\n    const type = InspectorTypes.flagDetailsChanged;\n    if (synchronousInspectorsByType[type].length) {\n      synchronousInspectorsByType[type].forEach(inspector => inspector.method(flags));\n    }\n    if (inspectorsByType[type].length) {\n      onNextTick(() => {\n        inspectorsByType[type].forEach(inspector => inspector.method(flags));\n      });\n    }\n  };\n\n  /**\n   * Notify registered inspectors that a flag value has changed.\n   *\n   * The notification itself will be dispatched asynchronously.\n   *\n   * @param {string} flagKey The key for the flag that changed.\n   * @param {Object} flag An `LDEvaluationDetail` for the flag.\n   */\n  manager.onFlagChanged = (flagKey, flag) => {\n    const type = InspectorTypes.flagDetailChanged;\n    if (synchronousInspectorsByType[type].length) {\n      synchronousInspectorsByType[type].forEach(inspector => inspector.method(flagKey, flag));\n    }\n    if (inspectorsByType[type].length) {\n      onNextTick(() => {\n        inspectorsByType[type].forEach(inspector => inspector.method(flagKey, flag));\n      });\n    }\n  };\n\n  /**\n   * Notify the registered inspectors that the context identity has changed.\n   *\n   * The notification itself will be dispatched asynchronously.\n   *\n   * @param {Object} context The `LDContext` which is now identified.\n   */\n  manager.onIdentityChanged = context => {\n    const type = InspectorTypes.clientIdentityChanged;\n    if (synchronousInspectorsByType[type].length) {\n      synchronousInspectorsByType[type].forEach(inspector => inspector.method(context));\n    }\n    if (inspectorsByType[type].length) {\n      onNextTick(() => {\n        inspectorsByType[type].forEach(inspector => inspector.method(context));\n      });\n    }\n  };\n\n  return manager;\n}\n\nmodule.exports = { InspectorTypes, InspectorManager };\n","const { LDTimeoutError } = require('./errors');\n\n/**\n * Returns a promise which errors after t seconds.\n *\n * @param t Timeout in seconds.\n * @param taskName Name of task being timed for logging and error reporting.\n */\nfunction timedPromise(t, taskName) {\n  return new Promise((_res, reject) => {\n    setTimeout(() => {\n      const e = `${taskName} timed out after ${t} seconds.`;\n      reject(new LDTimeoutError(e));\n    }, t * 1000);\n  });\n}\nmodule.exports = timedPromise;\n","const EventProcessor = require('./EventProcessor');\nconst EventEmitter = require('./EventEmitter');\nconst EventSender = require('./EventSender');\nconst InitializationStateTracker = require('./InitializationState');\nconst PersistentFlagStore = require('./PersistentFlagStore');\nconst PersistentStorage = require('./PersistentStorage');\nconst Stream = require('./Stream');\nconst Requestor = require('./Requestor');\nconst Identity = require('./Identity');\nconst AnonymousContextProcessor = require('./AnonymousContextProcessor');\nconst configuration = require('./configuration');\nconst diagnostics = require('./diagnosticEvents');\nconst { commonBasicLogger } = require('./loggers');\nconst utils = require('./utils');\nconst errors = require('./errors');\nconst messages = require('./messages');\nconst { checkContext, getContextKeys } = require('./context');\nconst { InspectorTypes, InspectorManager } = require('./InspectorManager');\nconst timedPromise = require('./timedPromise');\n\nconst changeEvent = 'change';\nconst internalChangeEvent = 'internal-change';\nconst highTimeoutThreshold = 5;\n\n// This is called by the per-platform initialize functions to create the base client object that we\n// may also extend with additional behavior. It returns an object with these properties:\n//   client: the actual client object\n//   options: the configuration (after any appropriate defaults have been applied)\n// If we need to give the platform-specific clients access to any internals here, we should add those\n// as properties of the return object, not public properties of the client.\n//\n// For definitions of the API in the platform object, see stubPlatform.js in the test code.\n\nfunction initialize(env, context, specifiedOptions, platform, extraOptionDefs) {\n  const logger = createLogger();\n  const emitter = EventEmitter(logger);\n  const initializationStateTracker = InitializationStateTracker(emitter);\n  const options = configuration.validate(specifiedOptions, emitter, extraOptionDefs, logger);\n  const inspectorManager = InspectorManager(options.inspectors, logger);\n  const sendEvents = options.sendEvents;\n  let environment = env;\n  let hash = options.hash;\n\n  const persistentStorage = PersistentStorage(platform.localStorage, logger);\n\n  const eventSender = EventSender(platform, environment, options);\n\n  const diagnosticsEnabled = options.sendEvents && !options.diagnosticOptOut;\n  const diagnosticId = diagnosticsEnabled ? diagnostics.DiagnosticId(environment) : null;\n  const diagnosticsAccumulator = diagnosticsEnabled ? diagnostics.DiagnosticsAccumulator(new Date().getTime()) : null;\n  const diagnosticsManager = diagnosticsEnabled\n    ? diagnostics.DiagnosticsManager(\n        platform,\n        persistentStorage,\n        diagnosticsAccumulator,\n        eventSender,\n        environment,\n        options,\n        diagnosticId\n      )\n    : null;\n\n  const stream = Stream(platform, options, environment, diagnosticsAccumulator);\n\n  const events =\n    options.eventProcessor ||\n    EventProcessor(platform, options, environment, diagnosticsAccumulator, emitter, eventSender);\n\n  const requestor = Requestor(platform, options, environment);\n\n  let flags = {};\n  let useLocalStorage;\n  let streamActive;\n  let streamForcedState = options.streaming;\n  let subscribedToChangeEvents;\n  let inited = false;\n  let closed = false;\n  let firstEvent = true;\n\n  // The \"stateProvider\" object is used in the Electron SDK, to allow one client instance to take partial\n  // control of another. If present, it has the following contract:\n  // - getInitialState() returns the initial client state if it is already available. The state is an\n  //   object whose properties are \"environment\", \"context\", and \"flags\".\n  // - on(\"init\", listener) triggers an event when the initial client state becomes available, passing\n  //   the state object to the listener.\n  // - on(\"update\", listener) triggers an event when flag values change and/or the current context changes.\n  //   The parameter is an object that *may* contain \"context\" and/or \"flags\".\n  // - enqueueEvent(event) accepts an analytics event object and returns true if the stateProvider will\n  //   be responsible for delivering it, or false if we still should deliver it ourselves.\n  const stateProvider = options.stateProvider;\n\n  const ident = Identity(null, onIdentifyChange);\n  const anonymousContextProcessor = new AnonymousContextProcessor(persistentStorage);\n  const persistentFlagStore = persistentStorage.isEnabled()\n    ? PersistentFlagStore(persistentStorage, environment, hash, ident, logger)\n    : null;\n\n  function createLogger() {\n    if (specifiedOptions && specifiedOptions.logger) {\n      return specifiedOptions.logger;\n    }\n    return (extraOptionDefs && extraOptionDefs.logger && extraOptionDefs.logger.default) || commonBasicLogger('warn');\n  }\n\n  function readFlagsFromBootstrap(data) {\n    // If the bootstrap data came from an older server-side SDK, we'll have just a map of keys to values.\n    // Newer SDKs that have an allFlagsState method will provide an extra \"$flagsState\" key that contains\n    // the rest of the metadata we want. We do it this way for backward compatibility with older JS SDKs.\n    const keys = Object.keys(data);\n    const metadataKey = '$flagsState';\n    const validKey = '$valid';\n    const metadata = data[metadataKey];\n    if (!metadata && keys.length) {\n      logger.warn(messages.bootstrapOldFormat());\n    }\n    if (data[validKey] === false) {\n      logger.warn(messages.bootstrapInvalid());\n    }\n    const ret = {};\n    keys.forEach(key => {\n      if (key !== metadataKey && key !== validKey) {\n        let flag = { value: data[key] };\n        if (metadata && metadata[key]) {\n          flag = utils.extend(flag, metadata[key]);\n        } else {\n          flag.version = 0;\n        }\n        ret[key] = flag;\n      }\n    });\n    return ret;\n  }\n\n  function shouldEnqueueEvent() {\n    return sendEvents && !closed && !platform.isDoNotTrack();\n  }\n\n  function enqueueEvent(event) {\n    if (!environment) {\n      // We're in paired mode and haven't been initialized with an environment or context yet\n      return;\n    }\n    if (stateProvider && stateProvider.enqueueEvent && stateProvider.enqueueEvent(event)) {\n      return; // it'll be handled elsewhere\n    }\n\n    if (!event.context) {\n      if (firstEvent) {\n        logger.warn(messages.eventWithoutContext());\n        firstEvent = false;\n      }\n      return;\n    }\n    firstEvent = false;\n\n    if (shouldEnqueueEvent()) {\n      logger.debug(messages.debugEnqueueingEvent(event.kind));\n      events.enqueue(event);\n    }\n  }\n\n  function notifyInspectionFlagUsed(key, detail) {\n    if (inspectorManager.hasListeners(InspectorTypes.flagUsed)) {\n      inspectorManager.onFlagUsed(key, detail, ident.getContext());\n    }\n  }\n\n  function notifyInspectionIdentityChanged() {\n    if (inspectorManager.hasListeners(InspectorTypes.clientIdentityChanged)) {\n      inspectorManager.onIdentityChanged(ident.getContext());\n    }\n  }\n\n  function notifyInspectionFlagChanged(data, newFlag) {\n    if (inspectorManager.hasListeners(InspectorTypes.flagDetailChanged)) {\n      inspectorManager.onFlagChanged(data.key, getFlagDetail(newFlag));\n    }\n  }\n\n  function notifyInspectionFlagsChanged() {\n    if (inspectorManager.hasListeners(InspectorTypes.flagDetailsChanged)) {\n      inspectorManager.onFlags(\n        Object.entries(flags)\n          .map(([key, value]) => ({ key, detail: getFlagDetail(value) }))\n          .reduce((acc, cur) => {\n            // eslint-disable-next-line no-param-reassign\n            acc[cur.key] = cur.detail;\n            return acc;\n          }, {})\n      );\n    }\n  }\n\n  function onIdentifyChange(context) {\n    sendIdentifyEvent(context);\n    notifyInspectionIdentityChanged();\n  }\n\n  function sendIdentifyEvent(context) {\n    if (stateProvider) {\n      // In paired mode, the other client is responsible for sending identify events\n      return;\n    }\n    if (context) {\n      enqueueEvent({\n        kind: 'identify',\n        context,\n        creationDate: new Date().getTime(),\n      });\n    }\n  }\n\n  function sendFlagEvent(key, detail, defaultValue, includeReason) {\n    const context = ident.getContext();\n    const now = new Date();\n    const value = detail ? detail.value : null;\n\n    const event = {\n      kind: 'feature',\n      key: key,\n      context,\n      value: value,\n      variation: detail ? detail.variationIndex : null,\n      default: defaultValue,\n      creationDate: now.getTime(),\n    };\n    const flag = flags[key];\n    if (flag) {\n      event.version = flag.flagVersion ? flag.flagVersion : flag.version;\n      event.trackEvents = flag.trackEvents;\n      event.debugEventsUntilDate = flag.debugEventsUntilDate;\n    }\n    if ((includeReason || (flag && flag.trackReason)) && detail) {\n      event.reason = detail.reason;\n    }\n\n    enqueueEvent(event);\n  }\n\n  function verifyContext(context) {\n    // The context will already have been processed to have a string key, so we\n    // do not need to allow for legacy keys in the check.\n    if (checkContext(context, false)) {\n      return Promise.resolve(context);\n    } else {\n      return Promise.reject(new errors.LDInvalidUserError(messages.invalidContext()));\n    }\n  }\n\n  function identify(context, newHash, onDone) {\n    if (closed) {\n      return utils.wrapPromiseCallback(Promise.resolve({}), onDone);\n    }\n    if (stateProvider) {\n      // We're being controlled by another client instance, so only that instance is allowed to change the context\n      logger.warn(messages.identifyDisabled());\n      return utils.wrapPromiseCallback(Promise.resolve(utils.transformVersionedValuesToValues(flags)), onDone);\n    }\n    const clearFirst = useLocalStorage && persistentFlagStore ? persistentFlagStore.clearFlags() : Promise.resolve();\n    return utils.wrapPromiseCallback(\n      clearFirst\n        .then(() => anonymousContextProcessor.processContext(context))\n        .then(verifyContext)\n        .then(validatedContext =>\n          requestor\n            .fetchFlagSettings(validatedContext, newHash)\n            // the following then() is nested within this one so we can use realUser from the previous closure\n            .then(requestedFlags => {\n              const flagValueMap = utils.transformVersionedValuesToValues(requestedFlags);\n              ident.setContext(validatedContext);\n              hash = newHash;\n              if (requestedFlags) {\n                return replaceAllFlags(requestedFlags).then(() => flagValueMap);\n              } else {\n                return flagValueMap;\n              }\n            })\n        )\n        .then(flagValueMap => {\n          if (streamActive) {\n            connectStream();\n          }\n          return flagValueMap;\n        })\n        .catch(err => {\n          emitter.maybeReportError(err);\n          return Promise.reject(err);\n        }),\n      onDone\n    );\n  }\n\n  function getContext() {\n    return ident.getContext();\n  }\n\n  function flush(onDone) {\n    return utils.wrapPromiseCallback(sendEvents ? events.flush() : Promise.resolve(), onDone);\n  }\n\n  function variation(key, defaultValue) {\n    return variationDetailInternal(key, defaultValue, true, false, false).value;\n  }\n\n  function variationDetail(key, defaultValue) {\n    return variationDetailInternal(key, defaultValue, true, true, false);\n  }\n\n  function variationDetailInternal(key, defaultValue, sendEvent, includeReasonInEvent, isAllFlags) {\n    let detail;\n\n    if (flags && utils.objectHasOwnProperty(flags, key) && flags[key] && !flags[key].deleted) {\n      const flag = flags[key];\n      detail = getFlagDetail(flag);\n      if (flag.value === null || flag.value === undefined) {\n        detail.value = defaultValue;\n      }\n    } else {\n      detail = { value: defaultValue, variationIndex: null, reason: { kind: 'ERROR', errorKind: 'FLAG_NOT_FOUND' } };\n    }\n\n    if (sendEvent) {\n      sendFlagEvent(key, detail, defaultValue, includeReasonInEvent);\n    }\n\n    // For the all flags case `onFlags` will be called instead.\n    if (!isAllFlags) {\n      notifyInspectionFlagUsed(key, detail);\n    }\n\n    return detail;\n  }\n\n  function getFlagDetail(flag) {\n    return {\n      value: flag.value,\n      variationIndex: flag.variation === undefined ? null : flag.variation,\n      reason: flag.reason || null,\n    };\n    // Note, the logic above ensures that variationIndex and reason will always be null rather than\n    // undefined if we don't have values for them. That's just to avoid subtle errors that depend on\n    // whether an object was JSON-encoded with null properties omitted or not.\n  }\n\n  function allFlags() {\n    const results = {};\n\n    if (!flags) {\n      return results;\n    }\n\n    for (const key in flags) {\n      if (utils.objectHasOwnProperty(flags, key) && !flags[key].deleted) {\n        results[key] = variationDetailInternal(key, null, !options.sendEventsOnlyForVariation, false, true).value;\n      }\n    }\n\n    return results;\n  }\n\n  function userContextKind(user) {\n    return user.anonymous ? 'anonymousUser' : 'user';\n  }\n\n  function track(key, data, metricValue) {\n    if (typeof key !== 'string') {\n      emitter.maybeReportError(new errors.LDInvalidEventKeyError(messages.unknownCustomEventKey(key)));\n      return;\n    }\n    if (metricValue !== undefined && typeof metricValue !== 'number') {\n      logger.warn(messages.invalidMetricValue(typeof metricValue));\n    }\n\n    // The following logic was used only for the JS browser SDK (js-client-sdk) and\n    // is no longer needed as of version 2.9.13 of that SDK. The other client-side\n    // JS-based SDKs did not define customEventFilter, and now none of them do. We\n    // can remove this in the next major version of the common code, when it's OK to\n    // make breaking changes to our internal API contracts.\n    if (platform.customEventFilter && !platform.customEventFilter(key)) {\n      logger.warn(messages.unknownCustomEventKey(key));\n    }\n\n    const context = ident.getContext();\n    const e = {\n      kind: 'custom',\n      key: key,\n      context,\n      url: platform.getCurrentUrl(),\n      creationDate: new Date().getTime(),\n    };\n    if (context && context.anonymous) {\n      e.contextKind = userContextKind(context);\n    }\n    // Note, check specifically for null/undefined because it is legal to set these fields to a falsey value.\n    if (data !== null && data !== undefined) {\n      e.data = data;\n    }\n    if (metricValue !== null && metricValue !== undefined) {\n      e.metricValue = metricValue;\n    }\n    enqueueEvent(e);\n  }\n\n  function connectStream() {\n    streamActive = true;\n    if (!ident.getContext()) {\n      return;\n    }\n    const tryParseData = jsonData => {\n      try {\n        return JSON.parse(jsonData);\n      } catch (err) {\n        emitter.maybeReportError(new errors.LDInvalidDataError(messages.invalidData()));\n        return undefined;\n      }\n    };\n    stream.connect(ident.getContext(), hash, {\n      ping: function() {\n        logger.debug(messages.debugStreamPing());\n        const contextAtTimeOfPingEvent = ident.getContext();\n        requestor\n          .fetchFlagSettings(contextAtTimeOfPingEvent, hash)\n          .then(requestedFlags => {\n            // Check whether the current context is still the same - we don't want to overwrite the flags if\n            // the application has called identify() while this request was in progress\n            if (utils.deepEquals(contextAtTimeOfPingEvent, ident.getContext())) {\n              replaceAllFlags(requestedFlags || {});\n            }\n          })\n          .catch(err => {\n            emitter.maybeReportError(new errors.LDFlagFetchError(messages.errorFetchingFlags(err)));\n          });\n      },\n      put: function(e) {\n        const data = tryParseData(e.data);\n        if (!data) {\n          return;\n        }\n        logger.debug(messages.debugStreamPut());\n        replaceAllFlags(data);\n        // Don't wait for this Promise to be resolved; note that replaceAllFlags is guaranteed\n        // never to have an unhandled rejection\n      },\n      patch: function(e) {\n        const data = tryParseData(e.data);\n        if (!data) {\n          return;\n        }\n        // If both the flag and the patch have a version property, then the patch version must be\n        // greater than the flag version for us to accept the patch.  If either one has no version\n        // then the patch always succeeds.\n        const oldFlag = flags[data.key];\n        if (!oldFlag || !oldFlag.version || !data.version || oldFlag.version < data.version) {\n          logger.debug(messages.debugStreamPatch(data.key));\n          const mods = {};\n          const newFlag = utils.extend({}, data);\n          delete newFlag['key'];\n          flags[data.key] = newFlag;\n          const newDetail = getFlagDetail(newFlag);\n          if (oldFlag) {\n            mods[data.key] = { previous: oldFlag.value, current: newDetail };\n          } else {\n            mods[data.key] = { current: newDetail };\n          }\n          notifyInspectionFlagChanged(data, newFlag);\n          handleFlagChanges(mods); // don't wait for this Promise to be resolved\n        } else {\n          logger.debug(messages.debugStreamPatchIgnored(data.key));\n        }\n      },\n      delete: function(e) {\n        const data = tryParseData(e.data);\n        if (!data) {\n          return;\n        }\n        if (!flags[data.key] || flags[data.key].version < data.version) {\n          logger.debug(messages.debugStreamDelete(data.key));\n          const mods = {};\n          if (flags[data.key] && !flags[data.key].deleted) {\n            mods[data.key] = { previous: flags[data.key].value };\n          }\n          flags[data.key] = { version: data.version, deleted: true };\n          notifyInspectionFlagChanged(data, flags[data.key]);\n          handleFlagChanges(mods); // don't wait for this Promise to be resolved\n        } else {\n          logger.debug(messages.debugStreamDeleteIgnored(data.key));\n        }\n      },\n    });\n  }\n\n  function disconnectStream() {\n    if (streamActive) {\n      stream.disconnect();\n      streamActive = false;\n    }\n  }\n\n  // Returns a Promise which will be resolved when we have completely updated the internal flags state,\n  // dispatched all change events, and updated local storage if appropriate. This Promise is guaranteed\n  // never to have an unhandled rejection.\n  function replaceAllFlags(newFlags) {\n    const changes = {};\n\n    if (!newFlags) {\n      return Promise.resolve();\n    }\n\n    for (const key in flags) {\n      if (utils.objectHasOwnProperty(flags, key) && flags[key]) {\n        if (newFlags[key] && !utils.deepEquals(newFlags[key].value, flags[key].value)) {\n          changes[key] = { previous: flags[key].value, current: getFlagDetail(newFlags[key]) };\n        } else if (!newFlags[key] || newFlags[key].deleted) {\n          changes[key] = { previous: flags[key].value };\n        }\n      }\n    }\n    for (const key in newFlags) {\n      if (utils.objectHasOwnProperty(newFlags, key) && newFlags[key] && (!flags[key] || flags[key].deleted)) {\n        changes[key] = { current: getFlagDetail(newFlags[key]) };\n      }\n    }\n\n    flags = { ...newFlags };\n\n    notifyInspectionFlagsChanged();\n\n    return handleFlagChanges(changes).catch(() => {}); // swallow any exceptions from this Promise\n  }\n\n  // Returns a Promise which will be resolved when we have dispatched all change events and updated\n  // local storage if appropriate.\n  function handleFlagChanges(changes) {\n    const keys = Object.keys(changes);\n\n    if (keys.length > 0) {\n      const changeEventParams = {};\n      keys.forEach(key => {\n        const current = changes[key].current;\n        const value = current ? current.value : undefined;\n        const previous = changes[key].previous;\n        emitter.emit(changeEvent + ':' + key, value, previous);\n        changeEventParams[key] = current ? { current: value, previous: previous } : { previous: previous };\n      });\n\n      emitter.emit(changeEvent, changeEventParams);\n      emitter.emit(internalChangeEvent, flags);\n\n      // By default, we send feature evaluation events whenever we have received new flag values -\n      // the client has in effect evaluated these flags just by receiving them. This can be suppressed\n      // by setting \"sendEventsOnlyForVariation\". Also, if we have a stateProvider, we don't send these\n      // events because we assume they have already been sent by the other client that gave us the flags\n      // (when it received them in the first place).\n      if (!options.sendEventsOnlyForVariation && !stateProvider) {\n        keys.forEach(key => {\n          sendFlagEvent(key, changes[key].current);\n        });\n      }\n    }\n\n    if (useLocalStorage && persistentFlagStore) {\n      return persistentFlagStore.saveFlags(flags);\n    } else {\n      return Promise.resolve();\n    }\n  }\n\n  function on(event, handler, context) {\n    if (isChangeEventKey(event)) {\n      subscribedToChangeEvents = true;\n      if (inited) {\n        updateStreamingState();\n      }\n      emitter.on(event, handler, context);\n    } else {\n      emitter.on(...arguments);\n    }\n  }\n\n  function off(event) {\n    emitter.off(...arguments);\n    if (isChangeEventKey(event)) {\n      let haveListeners = false;\n      emitter.getEvents().forEach(key => {\n        if (isChangeEventKey(key) && emitter.getEventListenerCount(key) > 0) {\n          haveListeners = true;\n        }\n      });\n      if (!haveListeners) {\n        subscribedToChangeEvents = false;\n        if (streamActive && streamForcedState === undefined) {\n          disconnectStream();\n        }\n      }\n    }\n  }\n\n  function setStreaming(state) {\n    const newState = state === null ? undefined : state;\n    if (newState !== streamForcedState) {\n      streamForcedState = newState;\n      updateStreamingState();\n    }\n  }\n\n  function updateStreamingState() {\n    const shouldBeStreaming = streamForcedState || (subscribedToChangeEvents && streamForcedState === undefined);\n    if (shouldBeStreaming && !streamActive) {\n      connectStream();\n    } else if (!shouldBeStreaming && streamActive) {\n      disconnectStream();\n    }\n    if (diagnosticsManager) {\n      diagnosticsManager.setStreaming(shouldBeStreaming);\n    }\n  }\n\n  function isChangeEventKey(event) {\n    return event === changeEvent || event.substr(0, changeEvent.length + 1) === changeEvent + ':';\n  }\n\n  if (typeof options.bootstrap === 'string' && options.bootstrap.toUpperCase() === 'LOCALSTORAGE') {\n    if (persistentFlagStore) {\n      useLocalStorage = true;\n    } else {\n      logger.warn(messages.localStorageUnavailable());\n    }\n  }\n\n  if (typeof options.bootstrap === 'object') {\n    // Set the flags as soon as possible before we get into any async code, so application code can read\n    // them even if the ready event has not yet fired.\n    flags = readFlagsFromBootstrap(options.bootstrap);\n  }\n\n  if (stateProvider) {\n    // The stateProvider option is used in the Electron SDK, to allow a client instance in the main process\n    // to control another client instance (i.e. this one) in the renderer process. We can't predict which\n    // one will start up first, so the initial state may already be available for us or we may have to wait\n    // to receive it.\n    const state = stateProvider.getInitialState();\n    if (state) {\n      initFromStateProvider(state);\n    } else {\n      stateProvider.on('init', initFromStateProvider);\n    }\n    stateProvider.on('update', updateFromStateProvider);\n  } else {\n    finishInit().catch(signalFailedInit);\n  }\n\n  function finishInit() {\n    if (!env) {\n      return Promise.reject(new errors.LDInvalidEnvironmentIdError(messages.environmentNotSpecified()));\n    }\n    return anonymousContextProcessor\n      .processContext(context)\n      .then(verifyContext)\n      .then(validatedContext => {\n        ident.setContext(validatedContext);\n        if (typeof options.bootstrap === 'object') {\n          // flags have already been set earlier\n          return signalSuccessfulInit();\n        } else if (useLocalStorage) {\n          return finishInitWithLocalStorage();\n        } else {\n          return finishInitWithPolling();\n        }\n      });\n  }\n\n  function finishInitWithLocalStorage() {\n    return persistentFlagStore.loadFlags().then(storedFlags => {\n      if (storedFlags === null || storedFlags === undefined) {\n        flags = {};\n        return requestor\n          .fetchFlagSettings(ident.getContext(), hash)\n          .then(requestedFlags => replaceAllFlags(requestedFlags || {}))\n          .then(signalSuccessfulInit)\n          .catch(err => {\n            const initErr = new errors.LDFlagFetchError(messages.errorFetchingFlags(err));\n            signalFailedInit(initErr);\n          });\n      } else {\n        // We're reading the flags from local storage. Signal that we're ready,\n        // then update localStorage for the next page load. We won't signal changes or update\n        // the in-memory flags unless you subscribe for changes\n        flags = storedFlags;\n        utils.onNextTick(signalSuccessfulInit);\n\n        return requestor\n          .fetchFlagSettings(ident.getContext(), hash)\n          .then(requestedFlags => replaceAllFlags(requestedFlags))\n          .catch(err => emitter.maybeReportError(err));\n      }\n    });\n  }\n\n  function finishInitWithPolling() {\n    return requestor\n      .fetchFlagSettings(ident.getContext(), hash)\n      .then(requestedFlags => {\n        flags = requestedFlags || {};\n\n        notifyInspectionFlagsChanged();\n        // Note, we don't need to call updateSettings here because local storage and change events are not relevant\n        signalSuccessfulInit();\n      })\n      .catch(err => {\n        flags = {};\n        signalFailedInit(err);\n      });\n  }\n\n  function initFromStateProvider(state) {\n    environment = state.environment;\n    ident.setContext(state.context);\n    flags = { ...state.flags };\n    utils.onNextTick(signalSuccessfulInit);\n  }\n\n  function updateFromStateProvider(state) {\n    if (state.context) {\n      ident.setContext(state.context);\n    }\n    if (state.flags) {\n      replaceAllFlags(state.flags); // don't wait for this Promise to be resolved\n    }\n  }\n\n  function signalSuccessfulInit() {\n    logger.info(messages.clientInitialized());\n    inited = true;\n    updateStreamingState();\n    initializationStateTracker.signalSuccess();\n  }\n\n  function signalFailedInit(err) {\n    initializationStateTracker.signalFailure(err);\n  }\n\n  function start() {\n    if (sendEvents) {\n      if (diagnosticsManager) {\n        diagnosticsManager.start();\n      }\n      events.start();\n    }\n  }\n\n  function close(onDone) {\n    if (closed) {\n      return utils.wrapPromiseCallback(Promise.resolve(), onDone);\n    }\n    const finishClose = () => {\n      closed = true;\n      flags = {};\n    };\n    const p = Promise.resolve()\n      .then(() => {\n        disconnectStream();\n        if (diagnosticsManager) {\n          diagnosticsManager.stop();\n        }\n        if (sendEvents) {\n          events.stop();\n          return events.flush();\n        }\n      })\n      .then(finishClose)\n      .catch(finishClose);\n    return utils.wrapPromiseCallback(p, onDone);\n  }\n\n  function getFlagsInternal() {\n    // used by Electron integration\n    return flags;\n  }\n\n  function waitForInitializationWithTimeout(timeout) {\n    if (timeout > highTimeoutThreshold) {\n      logger.warn(\n        'The waitForInitialization function was called with a timeout greater than ' +\n          `${highTimeoutThreshold} seconds. We recommend a timeout of ` +\n          `${highTimeoutThreshold} seconds or less.`\n      );\n    }\n\n    const initPromise = initializationStateTracker.getInitializationPromise();\n    const timeoutPromise = timedPromise(timeout, 'waitForInitialization');\n\n    return Promise.race([timeoutPromise, initPromise]).catch(e => {\n      if (e instanceof errors.LDTimeoutError) {\n        logger.error(`waitForInitialization error: ${e}`);\n      }\n      throw e;\n    });\n  }\n\n  function waitForInitialization(timeout = undefined) {\n    if (timeout !== undefined && timeout !== null) {\n      if (typeof timeout === 'number') {\n        return waitForInitializationWithTimeout(timeout);\n      }\n      logger.warn('The waitForInitialization method was provided with a non-numeric timeout.');\n    }\n    logger.warn(\n      'The waitForInitialization function was called without a timeout specified.' +\n        ' In a future version a default timeout will be applied.'\n    );\n    return initializationStateTracker.getInitializationPromise();\n  }\n\n  const client = {\n    waitForInitialization,\n    waitUntilReady: () => initializationStateTracker.getReadyPromise(),\n    identify: identify,\n    getContext: getContext,\n    variation: variation,\n    variationDetail: variationDetail,\n    track: track,\n    on: on,\n    off: off,\n    setStreaming: setStreaming,\n    flush: flush,\n    allFlags: allFlags,\n    close: close,\n  };\n\n  return {\n    client: client, // The client object containing all public methods.\n    options: options, // The validated configuration object, including all defaults.\n    emitter: emitter, // The event emitter which can be used to log errors or trigger events.\n    ident: ident, // The Identity object that manages the current context.\n    logger: logger, // The logging abstraction.\n    requestor: requestor, // The Requestor object.\n    start: start, // Starts the client once the environment is ready.\n    enqueueEvent: enqueueEvent, // Puts an analytics event in the queue, if event sending is enabled.\n    getFlagsInternal: getFlagsInternal, // Returns flag data structure with all details.\n    getEnvironmentId: () => environment, // Gets the environment ID (this may have changed since initialization, if we have a state provider)\n    internalChangeEventName: internalChangeEvent, // This event is triggered whenever we have new flag state.\n  };\n}\n\nmodule.exports = {\n  initialize,\n  commonBasicLogger,\n  errors,\n  messages,\n  utils,\n  getContextKeys,\n};\n","const { commonBasicLogger } = require('launchdarkly-js-sdk-common');\n\nfunction basicLogger(options) {\n  return commonBasicLogger({ destination: console.log, ...options });\n}\n\nmodule.exports = {\n  basicLogger,\n};\n","function isSyncXhrSupported() {\n  // This is temporary logic to disable synchronous XHR in Chrome 73 and above. In all other browsers,\n  // we will assume it is supported. See https://github.com/launchdarkly/js-client-sdk/issues/147\n  const userAgent = window.navigator && window.navigator.userAgent;\n  if (userAgent) {\n    const chromeMatch = userAgent.match(/Chrom(e|ium)\\/([0-9]+)\\./);\n    if (chromeMatch) {\n      const version = parseInt(chromeMatch[2], 10);\n      return version < 73;\n    }\n  }\n  return true;\n}\n\nconst emptyResult = { promise: Promise.resolve({ status: 200, header: () => null, body: null }) };\n\nexport default function newHttpRequest(method, url, headers, body, pageIsClosing) {\n  if (pageIsClosing) {\n    // When the page is about to close, we have to use synchronous XHR (until we migrate to sendBeacon).\n    // But not all browsers support this.\n    if (!isSyncXhrSupported()) {\n      return emptyResult;\n      // Note that we return a fake success response, because we don't want the request to be retried in this case.\n    }\n  }\n\n  const xhr = new window.XMLHttpRequest();\n  xhr.open(method, url, !pageIsClosing);\n  for (const key in headers || {}) {\n    if (Object.prototype.hasOwnProperty.call(headers, key)) {\n      xhr.setRequestHeader(key, headers[key]);\n    }\n  }\n  if (pageIsClosing) {\n    try {\n      xhr.send(body); // We specified synchronous mode when we called xhr.open\n    } catch (e) {\n      // do nothing intentionally to suppress noise for now\n    }\n    return emptyResult; // Again, we never want a request to be retried in this case, so we must say it succeeded.\n  } else {\n    let cancelled;\n    const p = new Promise((resolve, reject) => {\n      xhr.addEventListener('load', () => {\n        if (cancelled) {\n          return;\n        }\n        resolve({\n          status: xhr.status,\n          header: (key) => xhr.getResponseHeader(key),\n          body: xhr.responseText,\n        });\n      });\n      xhr.addEventListener('error', () => {\n        if (cancelled) {\n          return;\n        }\n        reject(new Error());\n      });\n      xhr.send(body);\n    });\n    const cancel = () => {\n      cancelled = true;\n      xhr.abort();\n    };\n    return { promise: p, cancel: cancel };\n  }\n}\n","'use strict';\n\nmodule.exports = string => {\n\tif (typeof string !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\t// Escape characters with special meaning either inside or outside character sets.\n\t// Use a simple backslash escape when its always valid, and a \\unnnn escape when the simpler form would be disallowed by Unicode patterns stricter grammar.\n\treturn string\n\t\t.replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&')\n\t\t.replace(/-/g, '\\\\x2d');\n};\n","import escapeStringRegexp from 'escape-string-regexp';\n\nexport function doesUrlMatch(matcher, href, search, hash) {\n  const keepHash = (matcher.kind === 'substring' || matcher.kind === 'regex') && hash.includes('/');\n  const canonicalUrl = (keepHash ? href : href.replace(hash, '')).replace(search, '');\n\n  let regex;\n  let testUrl;\n\n  switch (matcher.kind) {\n    case 'exact':\n      testUrl = href;\n      regex = new RegExp('^' + escapeStringRegexp(matcher.url) + '/?$');\n      break;\n    case 'canonical':\n      testUrl = canonicalUrl;\n      regex = new RegExp('^' + escapeStringRegexp(matcher.url) + '/?$');\n      break;\n    case 'substring':\n      testUrl = canonicalUrl;\n      regex = new RegExp('.*' + escapeStringRegexp(matcher.substring) + '.*$');\n      break;\n    case 'regex':\n      testUrl = canonicalUrl;\n      regex = new RegExp(matcher.pattern);\n      break;\n    default:\n      return false;\n  }\n  return regex.test(testUrl);\n}\n\nfunction findGoalsForClick(event, clickGoals) {\n  const matches = [];\n\n  for (let i = 0; i < clickGoals.length; i++) {\n    let target = event.target;\n    const goal = clickGoals[i];\n    const selector = goal.selector;\n    const elements = document.querySelectorAll(selector);\n    while (target && elements.length > 0) {\n      for (let j = 0; j < elements.length; j++) {\n        if (target === elements[j]) {\n          matches.push(goal);\n        }\n      }\n      target = target.parentNode;\n    }\n  }\n\n  return matches;\n}\n\nexport default function GoalTracker(goals, onEvent) {\n  const tracker = {};\n  let listenerFn = null;\n\n  const clickGoals = [];\n\n  for (let i = 0; i < goals.length; i++) {\n    const goal = goals[i];\n    const urls = goal.urls || [];\n\n    for (let j = 0; j < urls.length; j++) {\n      if (doesUrlMatch(urls[j], window.location.href, window.location.search, window.location.hash)) {\n        if (goal.kind === 'pageview') {\n          onEvent('pageview', goal);\n        } else {\n          clickGoals.push(goal);\n          onEvent('click_pageview', goal);\n        }\n        break;\n      }\n    }\n  }\n\n  if (clickGoals.length > 0) {\n    listenerFn = function (event) {\n      const goals = findGoalsForClick(event, clickGoals);\n      for (let i = 0; i < goals.length; i++) {\n        onEvent('click', goals[i]);\n      }\n    };\n\n    document.addEventListener('click', listenerFn);\n  }\n\n  tracker.dispose = function () {\n    document.removeEventListener('click', listenerFn);\n  };\n\n  return tracker;\n}\n","import * as common from 'launchdarkly-js-sdk-common';\nimport GoalTracker from './GoalTracker';\n\nconst locationWatcherInterval = 300;\n\nexport default function GoalManager(clientVars, readyCallback) {\n  let goals;\n  let goalTracker;\n\n  const ret = {};\n\n  function getGoalsPath() {\n    return '/sdk/goals/' + clientVars.getEnvironmentId();\n  }\n\n  function refreshGoalTracker() {\n    if (goalTracker) {\n      goalTracker.dispose();\n    }\n    if (goals && goals.length) {\n      goalTracker = GoalTracker(goals, sendGoalEvent);\n    }\n  }\n\n  function sendGoalEvent(kind, goal) {\n    const context = clientVars.ident.getContext();\n    const event = {\n      kind: kind,\n      key: goal.key,\n      data: null,\n      url: window.location.href,\n      creationDate: new Date().getTime(),\n      context: context,\n    };\n\n    if (kind === 'click') {\n      event.selector = goal.selector;\n    }\n\n    return clientVars.enqueueEvent(event);\n  }\n\n  function watchLocation(interval, callback) {\n    let previousUrl = window.location.href;\n    let currentUrl;\n\n    function checkUrl() {\n      currentUrl = window.location.href;\n\n      if (currentUrl !== previousUrl) {\n        previousUrl = currentUrl;\n        callback();\n      }\n    }\n\n    function poll(fn, interval) {\n      fn();\n      setTimeout(() => {\n        poll(fn, interval);\n      }, interval);\n    }\n\n    poll(checkUrl, interval);\n\n    if (window.history && window.history.pushState) {\n      window.addEventListener('popstate', checkUrl);\n    } else {\n      window.addEventListener('hashchange', checkUrl);\n    }\n  }\n\n  clientVars.requestor\n    .fetchJSON(getGoalsPath())\n    .then((g) => {\n      if (g && g.length > 0) {\n        goals = g;\n        goalTracker = GoalTracker(goals, sendGoalEvent);\n        watchLocation(locationWatcherInterval, refreshGoalTracker);\n      }\n      readyCallback();\n    })\n    .catch((err) => {\n      clientVars.emitter.maybeReportError(\n        new common.errors.LDUnexpectedResponseError('Error fetching goals: ' + (err && err.message) ? err.message : err)\n      );\n      readyCallback();\n    });\n\n  return ret;\n}\n","import * as common from 'launchdarkly-js-sdk-common';\nimport * as importBasicLogger from './basicLogger';\nimport browserPlatform from './browserPlatform';\nimport GoalManager from './GoalManager';\n\nconst goalsEvent = 'goalsReady';\nconst extraOptionDefs = {\n  fetchGoals: { default: true },\n  hash: { type: 'string' },\n  eventProcessor: { type: 'object' }, // used only in tests\n  eventUrlTransformer: { type: 'function' },\n  disableSyncEventPost: { default: false },\n};\n\n// Pass our platform object to the common code to create the browser version of the client\nexport function initialize(env, user, options = {}) {\n  const platform = browserPlatform(options);\n  const clientVars = common.initialize(env, user, options, platform, extraOptionDefs);\n\n  const client = clientVars.client;\n  const validatedOptions = clientVars.options;\n  const emitter = clientVars.emitter;\n\n  const goalsPromise = new Promise((resolve) => {\n    const onGoals = emitter.on(goalsEvent, () => {\n      emitter.off(goalsEvent, onGoals);\n      resolve();\n    });\n  });\n  client.waitUntilGoalsReady = () => goalsPromise;\n\n  if (validatedOptions.fetchGoals) {\n    GoalManager(clientVars, () => emitter.emit(goalsEvent));\n    // Don't need to save a reference to the GoalManager - its constructor takes care of setting\n    // up the necessary event wiring\n  } else {\n    emitter.emit(goalsEvent);\n  }\n\n  if (document.readyState !== 'complete') {\n    window.addEventListener('load', clientVars.start);\n  } else {\n    clientVars.start();\n  }\n\n  const syncFlush = () => {\n    // Synchronous events are not available in all browsers, but where they\n    // are we should attempt to use them. This increases the chance of the events\n    // being delivered.\n    platform.synchronousFlush = true;\n    client.flush().catch(() => {});\n    platform.synchronousFlush = false;\n  };\n\n  // When the visibility of the page changes to hidden we want to flush any pending events.\n  //\n  // This is handled with visibility, instead of beforeunload/unload\n  // because those events are not compatible with the bfcache and are unlikely\n  // to be called in many situations. For more information see: https://developer.chrome.com/blog/page-lifecycle-api/\n  //\n  // Redundancy is included by using both the visibilitychange handler as well as\n  // pagehide, because different browsers, and versions have different bugs with each.\n  // This also may provide more opportunity for the events to get flushed.\n  //\n  const handleVisibilityChange = () => {\n    if (document.visibilityState === 'hidden') {\n      syncFlush();\n    }\n  };\n\n  document.addEventListener('visibilitychange', handleVisibilityChange);\n  window.addEventListener('pagehide', syncFlush);\n\n  return client;\n}\n\nexport const basicLogger = importBasicLogger.basicLogger;\n\nexport const createConsoleLogger = common.createConsoleLogger;\n\nexport const version = VERSION;\n\nfunction deprecatedInitialize(env, user, options = {}) {\n  console && console.warn && console.warn(common.messages.deprecated('default export', 'named LDClient export')); // eslint-disable-line no-console\n  return initialize(env, user, options);\n}\n\nexport default { initialize: deprecatedInitialize, version };\n","import newHttpRequest from './httpRequest';\n\nexport default function makeBrowserPlatform(options) {\n  const ret = {\n    userAgentHeaderName: 'X-LaunchDarkly-User-Agent',\n  };\n\n  ret.synchronousFlush = false; // this will be set to true by index.js if the page is hidden\n\n  // XMLHttpRequest may not exist if we're running in a server-side rendering context\n  if (window.XMLHttpRequest) {\n    const disableSyncFlush = options && options.disableSyncEventPost;\n    ret.httpRequest = (method, url, headers, body) => {\n      const syncFlush = ret.synchronousFlush & !disableSyncFlush;\n      ret.synchronousFlush = false;\n      return newHttpRequest(method, url, headers, body, syncFlush);\n    };\n  }\n\n  let hasCors;\n  ret.httpAllowsPost = () => {\n    // We compute this lazily because calling XMLHttpRequest() at initialization time can disrupt tests\n    if (hasCors === undefined) {\n      hasCors = window.XMLHttpRequest ? 'withCredentials' in new window.XMLHttpRequest() : false;\n    }\n    return hasCors;\n  };\n\n  // Image-based mechanism for sending events if POST isn't available\n  ret.httpFallbackPing = (url) => {\n    const img = new window.Image();\n    img.src = url;\n  };\n\n  const eventUrlTransformer = options && options.eventUrlTransformer;\n  ret.getCurrentUrl = () => (eventUrlTransformer ? eventUrlTransformer(window.location.href) : window.location.href);\n\n  ret.isDoNotTrack = () => {\n    let flag;\n    if (window.navigator && window.navigator.doNotTrack !== undefined) {\n      flag = window.navigator.doNotTrack; // FF, Chrome\n    } else if (window.navigator && window.navigator.msDoNotTrack !== undefined) {\n      flag = window.navigator.msDoNotTrack; // IE 9/10\n    } else {\n      flag = window.doNotTrack; // IE 11+, Safari\n    }\n    return flag === 1 || flag === true || flag === '1' || flag === 'yes';\n  };\n\n  try {\n    if (window.localStorage) {\n      ret.localStorage = {\n        get: (key) =>\n          new Promise((resolve) => {\n            resolve(window.localStorage.getItem(key));\n          }),\n        set: (key, value) =>\n          new Promise((resolve) => {\n            window.localStorage.setItem(key, value);\n            resolve();\n          }),\n        clear: (key) =>\n          new Promise((resolve) => {\n            window.localStorage.removeItem(key);\n            resolve();\n          }),\n      };\n    }\n  } catch (e) {\n    // In some browsers (such as Chrome), even looking at window.localStorage at all will cause a\n    // security error if the feature is disabled.\n    ret.localStorage = null;\n  }\n\n  // The browser built-in EventSource implementations do not support setting the method used for\n  // the request. When useReport is true, we ensure sending the user in the body of a REPORT request\n  // rather than in the URL path. If a polyfill for EventSource that supports setting the request\n  // method is provided (currently, launchdarkly-eventsource is the only polyfill that both supports\n  // it and gives us a way to *know* that it supports it), we use the polyfill to connect to a flag\n  // stream that will provide evaluated flags for the specific user. Otherwise, when useReport is\n  // true, we fall back to a generic  'ping' stream that informs the SDK to make a separate REPORT\n  // request for the user's flag evaluations whenever the flag definitions have been updated.\n  let eventSourceConstructor;\n  const useReport = options && options.useReport;\n  if (\n    useReport &&\n    typeof window.EventSourcePolyfill === 'function' &&\n    window.EventSourcePolyfill.supportedOptions &&\n    window.EventSourcePolyfill.supportedOptions.method\n  ) {\n    ret.eventSourceAllowsReport = true;\n    eventSourceConstructor = window.EventSourcePolyfill;\n  } else {\n    ret.eventSourceAllowsReport = false;\n    eventSourceConstructor = window.EventSource;\n  }\n\n  // If EventSource does not exist, the absence of eventSourceFactory will make us not try to open streams\n  if (window.EventSource) {\n    const timeoutMillis = 300000; // this is only used by polyfills - see below\n\n    ret.eventSourceFactory = (url, options) => {\n      // The standard EventSource constructor doesn't take any options, just a URL. However, some\n      // EventSource polyfills allow us to specify a timeout interval, and in some cases they will\n      // default to a too-short timeout if we don't specify one. So, here, we are setting the\n      // timeout properties that are used by several popular polyfills.\n      // Also, the skipDefaultHeaders property (if supported) tells the polyfill not to add the\n      // Cache-Control header that can cause CORS problems in browsers.\n      // See: https://github.com/launchdarkly/js-eventsource\n      const defaultOptions = {\n        heartbeatTimeout: timeoutMillis,\n        silentTimeout: timeoutMillis,\n        skipDefaultHeaders: true,\n      };\n\n      const esOptions = { ...defaultOptions, ...options };\n\n      return new eventSourceConstructor(url, esOptions);\n    };\n\n    ret.eventSourceIsActive = (es) =>\n      es.readyState === window.EventSource.OPEN || es.readyState === window.EventSource.CONNECTING;\n  }\n\n  ret.userAgent = 'JSClient';\n  ret.version = VERSION;\n\n  ret.diagnosticSdkData = {\n    name: 'js-client-sdk',\n    version: VERSION,\n  };\n\n  ret.diagnosticPlatformData = {\n    name: 'JS',\n  };\n\n  ret.diagnosticUseCombinedEvent = true; // the browser SDK uses the \"diagnostic-combined\" event format\n\n  return ret;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}